// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/biryanim/avito-tech-pvz/internal/repository.PvzRepository -o pvz_repository_minimock.go -n PvzRepositoryMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/biryanim/avito-tech-pvz/internal/model"
	"github.com/gojuno/minimock/v3"
	"github.com/google/uuid"
)

// PvzRepositoryMock implements mm_repository.PvzRepository
type PvzRepositoryMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCreate          func(ctx context.Context, pvz *model.PVZInfo) (pp1 *model.PVZ, err error)
	funcCreateOrigin    string
	inspectFuncCreate   func(ctx context.Context, pvz *model.PVZInfo)
	afterCreateCounter  uint64
	beforeCreateCounter uint64
	CreateMock          mPvzRepositoryMockCreate

	funcCreateProduct          func(ctx context.Context, product *model.ProductInfo) (pp1 *model.Product, err error)
	funcCreateProductOrigin    string
	inspectFuncCreateProduct   func(ctx context.Context, product *model.ProductInfo)
	afterCreateProductCounter  uint64
	beforeCreateProductCounter uint64
	CreateProductMock          mPvzRepositoryMockCreateProduct

	funcCreateReception          func(ctx context.Context, pvzId uuid.UUID) (rp1 *model.Reception, err error)
	funcCreateReceptionOrigin    string
	inspectFuncCreateReception   func(ctx context.Context, pvzId uuid.UUID)
	afterCreateReceptionCounter  uint64
	beforeCreateReceptionCounter uint64
	CreateReceptionMock          mPvzRepositoryMockCreateReception

	funcDeleteLastProduct          func(ctx context.Context, receptionId uuid.UUID) (err error)
	funcDeleteLastProductOrigin    string
	inspectFuncDeleteLastProduct   func(ctx context.Context, receptionId uuid.UUID)
	afterDeleteLastProductCounter  uint64
	beforeDeleteLastProductCounter uint64
	DeleteLastProductMock          mPvzRepositoryMockDeleteLastProduct

	funcGetLastReception          func(ctx context.Context, pvzId uuid.UUID) (rp1 *model.Reception, err error)
	funcGetLastReceptionOrigin    string
	inspectFuncGetLastReception   func(ctx context.Context, pvzId uuid.UUID)
	afterGetLastReceptionCounter  uint64
	beforeGetLastReceptionCounter uint64
	GetLastReceptionMock          mPvzRepositoryMockGetLastReception

	funcGetListPVZ          func(ctx context.Context, pagination *model.Filter) (ppa1 []*model.PVZWithReceptions, err error)
	funcGetListPVZOrigin    string
	inspectFuncGetListPVZ   func(ctx context.Context, pagination *model.Filter)
	afterGetListPVZCounter  uint64
	beforeGetListPVZCounter uint64
	GetListPVZMock          mPvzRepositoryMockGetListPVZ

	funcUpdateReception          func(ctx context.Context, receptionId uuid.UUID) (err error)
	funcUpdateReceptionOrigin    string
	inspectFuncUpdateReception   func(ctx context.Context, receptionId uuid.UUID)
	afterUpdateReceptionCounter  uint64
	beforeUpdateReceptionCounter uint64
	UpdateReceptionMock          mPvzRepositoryMockUpdateReception
}

// NewPvzRepositoryMock returns a mock for mm_repository.PvzRepository
func NewPvzRepositoryMock(t minimock.Tester) *PvzRepositoryMock {
	m := &PvzRepositoryMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CreateMock = mPvzRepositoryMockCreate{mock: m}
	m.CreateMock.callArgs = []*PvzRepositoryMockCreateParams{}

	m.CreateProductMock = mPvzRepositoryMockCreateProduct{mock: m}
	m.CreateProductMock.callArgs = []*PvzRepositoryMockCreateProductParams{}

	m.CreateReceptionMock = mPvzRepositoryMockCreateReception{mock: m}
	m.CreateReceptionMock.callArgs = []*PvzRepositoryMockCreateReceptionParams{}

	m.DeleteLastProductMock = mPvzRepositoryMockDeleteLastProduct{mock: m}
	m.DeleteLastProductMock.callArgs = []*PvzRepositoryMockDeleteLastProductParams{}

	m.GetLastReceptionMock = mPvzRepositoryMockGetLastReception{mock: m}
	m.GetLastReceptionMock.callArgs = []*PvzRepositoryMockGetLastReceptionParams{}

	m.GetListPVZMock = mPvzRepositoryMockGetListPVZ{mock: m}
	m.GetListPVZMock.callArgs = []*PvzRepositoryMockGetListPVZParams{}

	m.UpdateReceptionMock = mPvzRepositoryMockUpdateReception{mock: m}
	m.UpdateReceptionMock.callArgs = []*PvzRepositoryMockUpdateReceptionParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mPvzRepositoryMockCreate struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockCreateExpectation
	expectations       []*PvzRepositoryMockCreateExpectation

	callArgs []*PvzRepositoryMockCreateParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockCreateExpectation specifies expectation struct of the PvzRepository.Create
type PvzRepositoryMockCreateExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockCreateParams
	paramPtrs          *PvzRepositoryMockCreateParamPtrs
	expectationOrigins PvzRepositoryMockCreateExpectationOrigins
	results            *PvzRepositoryMockCreateResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockCreateParams contains parameters of the PvzRepository.Create
type PvzRepositoryMockCreateParams struct {
	ctx context.Context
	pvz *model.PVZInfo
}

// PvzRepositoryMockCreateParamPtrs contains pointers to parameters of the PvzRepository.Create
type PvzRepositoryMockCreateParamPtrs struct {
	ctx *context.Context
	pvz **model.PVZInfo
}

// PvzRepositoryMockCreateResults contains results of the PvzRepository.Create
type PvzRepositoryMockCreateResults struct {
	pp1 *model.PVZ
	err error
}

// PvzRepositoryMockCreateOrigins contains origins of expectations of the PvzRepository.Create
type PvzRepositoryMockCreateExpectationOrigins struct {
	origin    string
	originCtx string
	originPvz string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreate *mPvzRepositoryMockCreate) Optional() *mPvzRepositoryMockCreate {
	mmCreate.optional = true
	return mmCreate
}

// Expect sets up expected params for PvzRepository.Create
func (mmCreate *mPvzRepositoryMockCreate) Expect(ctx context.Context, pvz *model.PVZInfo) *mPvzRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PvzRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.paramPtrs != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by ExpectParams functions")
	}

	mmCreate.defaultExpectation.params = &PvzRepositoryMockCreateParams{ctx, pvz}
	mmCreate.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreate.expectations {
		if minimock.Equal(e.params, mmCreate.defaultExpectation.params) {
			mmCreate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreate.defaultExpectation.params)
		}
	}

	return mmCreate
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.Create
func (mmCreate *mPvzRepositoryMockCreate) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PvzRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PvzRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreate.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreate
}

// ExpectPvzParam2 sets up expected param pvz for PvzRepository.Create
func (mmCreate *mPvzRepositoryMockCreate) ExpectPvzParam2(pvz *model.PVZInfo) *mPvzRepositoryMockCreate {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PvzRepositoryMockCreateExpectation{}
	}

	if mmCreate.defaultExpectation.params != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Expect")
	}

	if mmCreate.defaultExpectation.paramPtrs == nil {
		mmCreate.defaultExpectation.paramPtrs = &PvzRepositoryMockCreateParamPtrs{}
	}
	mmCreate.defaultExpectation.paramPtrs.pvz = &pvz
	mmCreate.defaultExpectation.expectationOrigins.originPvz = minimock.CallerInfo(1)

	return mmCreate
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.Create
func (mmCreate *mPvzRepositoryMockCreate) Inspect(f func(ctx context.Context, pvz *model.PVZInfo)) *mPvzRepositoryMockCreate {
	if mmCreate.mock.inspectFuncCreate != nil {
		mmCreate.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.Create")
	}

	mmCreate.mock.inspectFuncCreate = f

	return mmCreate
}

// Return sets up results that will be returned by PvzRepository.Create
func (mmCreate *mPvzRepositoryMockCreate) Return(pp1 *model.PVZ, err error) *PvzRepositoryMock {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Set")
	}

	if mmCreate.defaultExpectation == nil {
		mmCreate.defaultExpectation = &PvzRepositoryMockCreateExpectation{mock: mmCreate.mock}
	}
	mmCreate.defaultExpectation.results = &PvzRepositoryMockCreateResults{pp1, err}
	mmCreate.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// Set uses given function f to mock the PvzRepository.Create method
func (mmCreate *mPvzRepositoryMockCreate) Set(f func(ctx context.Context, pvz *model.PVZInfo) (pp1 *model.PVZ, err error)) *PvzRepositoryMock {
	if mmCreate.defaultExpectation != nil {
		mmCreate.mock.t.Fatalf("Default expectation is already set for the PvzRepository.Create method")
	}

	if len(mmCreate.expectations) > 0 {
		mmCreate.mock.t.Fatalf("Some expectations are already set for the PvzRepository.Create method")
	}

	mmCreate.mock.funcCreate = f
	mmCreate.mock.funcCreateOrigin = minimock.CallerInfo(1)
	return mmCreate.mock
}

// When sets expectation for the PvzRepository.Create which will trigger the result defined by the following
// Then helper
func (mmCreate *mPvzRepositoryMockCreate) When(ctx context.Context, pvz *model.PVZInfo) *PvzRepositoryMockCreateExpectation {
	if mmCreate.mock.funcCreate != nil {
		mmCreate.mock.t.Fatalf("PvzRepositoryMock.Create mock is already set by Set")
	}

	expectation := &PvzRepositoryMockCreateExpectation{
		mock:               mmCreate.mock,
		params:             &PvzRepositoryMockCreateParams{ctx, pvz},
		expectationOrigins: PvzRepositoryMockCreateExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreate.expectations = append(mmCreate.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.Create return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockCreateExpectation) Then(pp1 *model.PVZ, err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockCreateResults{pp1, err}
	return e.mock
}

// Times sets number of times PvzRepository.Create should be invoked
func (mmCreate *mPvzRepositoryMockCreate) Times(n uint64) *mPvzRepositoryMockCreate {
	if n == 0 {
		mmCreate.mock.t.Fatalf("Times of PvzRepositoryMock.Create mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreate.expectedInvocations, n)
	mmCreate.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreate
}

func (mmCreate *mPvzRepositoryMockCreate) invocationsDone() bool {
	if len(mmCreate.expectations) == 0 && mmCreate.defaultExpectation == nil && mmCreate.mock.funcCreate == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreate.mock.afterCreateCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreate.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Create implements mm_repository.PvzRepository
func (mmCreate *PvzRepositoryMock) Create(ctx context.Context, pvz *model.PVZInfo) (pp1 *model.PVZ, err error) {
	mm_atomic.AddUint64(&mmCreate.beforeCreateCounter, 1)
	defer mm_atomic.AddUint64(&mmCreate.afterCreateCounter, 1)

	mmCreate.t.Helper()

	if mmCreate.inspectFuncCreate != nil {
		mmCreate.inspectFuncCreate(ctx, pvz)
	}

	mm_params := PvzRepositoryMockCreateParams{ctx, pvz}

	// Record call args
	mmCreate.CreateMock.mutex.Lock()
	mmCreate.CreateMock.callArgs = append(mmCreate.CreateMock.callArgs, &mm_params)
	mmCreate.CreateMock.mutex.Unlock()

	for _, e := range mmCreate.CreateMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmCreate.CreateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreate.CreateMock.defaultExpectation.Counter, 1)
		mm_want := mmCreate.CreateMock.defaultExpectation.params
		mm_want_ptrs := mmCreate.CreateMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockCreateParams{ctx, pvz}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreate.t.Errorf("PvzRepositoryMock.Create got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvz != nil && !minimock.Equal(*mm_want_ptrs.pvz, mm_got.pvz) {
				mmCreate.t.Errorf("PvzRepositoryMock.Create got unexpected parameter pvz, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreate.CreateMock.defaultExpectation.expectationOrigins.originPvz, *mm_want_ptrs.pvz, mm_got.pvz, minimock.Diff(*mm_want_ptrs.pvz, mm_got.pvz))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreate.t.Errorf("PvzRepositoryMock.Create got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreate.CreateMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreate.CreateMock.defaultExpectation.results
		if mm_results == nil {
			mmCreate.t.Fatal("No results are set for the PvzRepositoryMock.Create")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmCreate.funcCreate != nil {
		return mmCreate.funcCreate(ctx, pvz)
	}
	mmCreate.t.Fatalf("Unexpected call to PvzRepositoryMock.Create. %v %v", ctx, pvz)
	return
}

// CreateAfterCounter returns a count of finished PvzRepositoryMock.Create invocations
func (mmCreate *PvzRepositoryMock) CreateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.afterCreateCounter)
}

// CreateBeforeCounter returns a count of PvzRepositoryMock.Create invocations
func (mmCreate *PvzRepositoryMock) CreateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreate.beforeCreateCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.Create.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreate *mPvzRepositoryMockCreate) Calls() []*PvzRepositoryMockCreateParams {
	mmCreate.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockCreateParams, len(mmCreate.callArgs))
	copy(argCopy, mmCreate.callArgs)

	mmCreate.mutex.RUnlock()

	return argCopy
}

// MinimockCreateDone returns true if the count of the Create invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockCreateDone() bool {
	if m.CreateMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateMock.invocationsDone()
}

// MinimockCreateInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockCreateInspect() {
	for _, e := range m.CreateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.Create at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateCounter := mm_atomic.LoadUint64(&m.afterCreateCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateMock.defaultExpectation != nil && afterCreateCounter < 1 {
		if m.CreateMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.Create at\n%s", m.CreateMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.Create at\n%s with params: %#v", m.CreateMock.defaultExpectation.expectationOrigins.origin, *m.CreateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreate != nil && afterCreateCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.Create at\n%s", m.funcCreateOrigin)
	}

	if !m.CreateMock.invocationsDone() && afterCreateCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.Create at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateMock.expectedInvocations), m.CreateMock.expectedInvocationsOrigin, afterCreateCounter)
	}
}

type mPvzRepositoryMockCreateProduct struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockCreateProductExpectation
	expectations       []*PvzRepositoryMockCreateProductExpectation

	callArgs []*PvzRepositoryMockCreateProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockCreateProductExpectation specifies expectation struct of the PvzRepository.CreateProduct
type PvzRepositoryMockCreateProductExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockCreateProductParams
	paramPtrs          *PvzRepositoryMockCreateProductParamPtrs
	expectationOrigins PvzRepositoryMockCreateProductExpectationOrigins
	results            *PvzRepositoryMockCreateProductResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockCreateProductParams contains parameters of the PvzRepository.CreateProduct
type PvzRepositoryMockCreateProductParams struct {
	ctx     context.Context
	product *model.ProductInfo
}

// PvzRepositoryMockCreateProductParamPtrs contains pointers to parameters of the PvzRepository.CreateProduct
type PvzRepositoryMockCreateProductParamPtrs struct {
	ctx     *context.Context
	product **model.ProductInfo
}

// PvzRepositoryMockCreateProductResults contains results of the PvzRepository.CreateProduct
type PvzRepositoryMockCreateProductResults struct {
	pp1 *model.Product
	err error
}

// PvzRepositoryMockCreateProductOrigins contains origins of expectations of the PvzRepository.CreateProduct
type PvzRepositoryMockCreateProductExpectationOrigins struct {
	origin        string
	originCtx     string
	originProduct string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Optional() *mPvzRepositoryMockCreateProduct {
	mmCreateProduct.optional = true
	return mmCreateProduct
}

// Expect sets up expected params for PvzRepository.CreateProduct
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Expect(ctx context.Context, product *model.ProductInfo) *mPvzRepositoryMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &PvzRepositoryMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.paramPtrs != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by ExpectParams functions")
	}

	mmCreateProduct.defaultExpectation.params = &PvzRepositoryMockCreateProductParams{ctx, product}
	mmCreateProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateProduct.expectations {
		if minimock.Equal(e.params, mmCreateProduct.defaultExpectation.params) {
			mmCreateProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateProduct.defaultExpectation.params)
		}
	}

	return mmCreateProduct
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.CreateProduct
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &PvzRepositoryMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &PvzRepositoryMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateProduct
}

// ExpectProductParam2 sets up expected param product for PvzRepository.CreateProduct
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) ExpectProductParam2(product *model.ProductInfo) *mPvzRepositoryMockCreateProduct {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &PvzRepositoryMockCreateProductExpectation{}
	}

	if mmCreateProduct.defaultExpectation.params != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Expect")
	}

	if mmCreateProduct.defaultExpectation.paramPtrs == nil {
		mmCreateProduct.defaultExpectation.paramPtrs = &PvzRepositoryMockCreateProductParamPtrs{}
	}
	mmCreateProduct.defaultExpectation.paramPtrs.product = &product
	mmCreateProduct.defaultExpectation.expectationOrigins.originProduct = minimock.CallerInfo(1)

	return mmCreateProduct
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.CreateProduct
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Inspect(f func(ctx context.Context, product *model.ProductInfo)) *mPvzRepositoryMockCreateProduct {
	if mmCreateProduct.mock.inspectFuncCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.CreateProduct")
	}

	mmCreateProduct.mock.inspectFuncCreateProduct = f

	return mmCreateProduct
}

// Return sets up results that will be returned by PvzRepository.CreateProduct
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Return(pp1 *model.Product, err error) *PvzRepositoryMock {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Set")
	}

	if mmCreateProduct.defaultExpectation == nil {
		mmCreateProduct.defaultExpectation = &PvzRepositoryMockCreateProductExpectation{mock: mmCreateProduct.mock}
	}
	mmCreateProduct.defaultExpectation.results = &PvzRepositoryMockCreateProductResults{pp1, err}
	mmCreateProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// Set uses given function f to mock the PvzRepository.CreateProduct method
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Set(f func(ctx context.Context, product *model.ProductInfo) (pp1 *model.Product, err error)) *PvzRepositoryMock {
	if mmCreateProduct.defaultExpectation != nil {
		mmCreateProduct.mock.t.Fatalf("Default expectation is already set for the PvzRepository.CreateProduct method")
	}

	if len(mmCreateProduct.expectations) > 0 {
		mmCreateProduct.mock.t.Fatalf("Some expectations are already set for the PvzRepository.CreateProduct method")
	}

	mmCreateProduct.mock.funcCreateProduct = f
	mmCreateProduct.mock.funcCreateProductOrigin = minimock.CallerInfo(1)
	return mmCreateProduct.mock
}

// When sets expectation for the PvzRepository.CreateProduct which will trigger the result defined by the following
// Then helper
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) When(ctx context.Context, product *model.ProductInfo) *PvzRepositoryMockCreateProductExpectation {
	if mmCreateProduct.mock.funcCreateProduct != nil {
		mmCreateProduct.mock.t.Fatalf("PvzRepositoryMock.CreateProduct mock is already set by Set")
	}

	expectation := &PvzRepositoryMockCreateProductExpectation{
		mock:               mmCreateProduct.mock,
		params:             &PvzRepositoryMockCreateProductParams{ctx, product},
		expectationOrigins: PvzRepositoryMockCreateProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateProduct.expectations = append(mmCreateProduct.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.CreateProduct return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockCreateProductExpectation) Then(pp1 *model.Product, err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockCreateProductResults{pp1, err}
	return e.mock
}

// Times sets number of times PvzRepository.CreateProduct should be invoked
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Times(n uint64) *mPvzRepositoryMockCreateProduct {
	if n == 0 {
		mmCreateProduct.mock.t.Fatalf("Times of PvzRepositoryMock.CreateProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateProduct.expectedInvocations, n)
	mmCreateProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateProduct
}

func (mmCreateProduct *mPvzRepositoryMockCreateProduct) invocationsDone() bool {
	if len(mmCreateProduct.expectations) == 0 && mmCreateProduct.defaultExpectation == nil && mmCreateProduct.mock.funcCreateProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateProduct.mock.afterCreateProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateProduct implements mm_repository.PvzRepository
func (mmCreateProduct *PvzRepositoryMock) CreateProduct(ctx context.Context, product *model.ProductInfo) (pp1 *model.Product, err error) {
	mm_atomic.AddUint64(&mmCreateProduct.beforeCreateProductCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateProduct.afterCreateProductCounter, 1)

	mmCreateProduct.t.Helper()

	if mmCreateProduct.inspectFuncCreateProduct != nil {
		mmCreateProduct.inspectFuncCreateProduct(ctx, product)
	}

	mm_params := PvzRepositoryMockCreateProductParams{ctx, product}

	// Record call args
	mmCreateProduct.CreateProductMock.mutex.Lock()
	mmCreateProduct.CreateProductMock.callArgs = append(mmCreateProduct.CreateProductMock.callArgs, &mm_params)
	mmCreateProduct.CreateProductMock.mutex.Unlock()

	for _, e := range mmCreateProduct.CreateProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmCreateProduct.CreateProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateProduct.CreateProductMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateProduct.CreateProductMock.defaultExpectation.params
		mm_want_ptrs := mmCreateProduct.CreateProductMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockCreateProductParams{ctx, product}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateProduct.t.Errorf("PvzRepositoryMock.CreateProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.product != nil && !minimock.Equal(*mm_want_ptrs.product, mm_got.product) {
				mmCreateProduct.t.Errorf("PvzRepositoryMock.CreateProduct got unexpected parameter product, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.originProduct, *mm_want_ptrs.product, mm_got.product, minimock.Diff(*mm_want_ptrs.product, mm_got.product))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateProduct.t.Errorf("PvzRepositoryMock.CreateProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateProduct.CreateProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateProduct.CreateProductMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateProduct.t.Fatal("No results are set for the PvzRepositoryMock.CreateProduct")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmCreateProduct.funcCreateProduct != nil {
		return mmCreateProduct.funcCreateProduct(ctx, product)
	}
	mmCreateProduct.t.Fatalf("Unexpected call to PvzRepositoryMock.CreateProduct. %v %v", ctx, product)
	return
}

// CreateProductAfterCounter returns a count of finished PvzRepositoryMock.CreateProduct invocations
func (mmCreateProduct *PvzRepositoryMock) CreateProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.afterCreateProductCounter)
}

// CreateProductBeforeCounter returns a count of PvzRepositoryMock.CreateProduct invocations
func (mmCreateProduct *PvzRepositoryMock) CreateProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateProduct.beforeCreateProductCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.CreateProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateProduct *mPvzRepositoryMockCreateProduct) Calls() []*PvzRepositoryMockCreateProductParams {
	mmCreateProduct.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockCreateProductParams, len(mmCreateProduct.callArgs))
	copy(argCopy, mmCreateProduct.callArgs)

	mmCreateProduct.mutex.RUnlock()

	return argCopy
}

// MinimockCreateProductDone returns true if the count of the CreateProduct invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockCreateProductDone() bool {
	if m.CreateProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateProductMock.invocationsDone()
}

// MinimockCreateProductInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockCreateProductInspect() {
	for _, e := range m.CreateProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.CreateProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateProductCounter := mm_atomic.LoadUint64(&m.afterCreateProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateProductMock.defaultExpectation != nil && afterCreateProductCounter < 1 {
		if m.CreateProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.CreateProduct at\n%s", m.CreateProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.CreateProduct at\n%s with params: %#v", m.CreateProductMock.defaultExpectation.expectationOrigins.origin, *m.CreateProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateProduct != nil && afterCreateProductCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.CreateProduct at\n%s", m.funcCreateProductOrigin)
	}

	if !m.CreateProductMock.invocationsDone() && afterCreateProductCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.CreateProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateProductMock.expectedInvocations), m.CreateProductMock.expectedInvocationsOrigin, afterCreateProductCounter)
	}
}

type mPvzRepositoryMockCreateReception struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockCreateReceptionExpectation
	expectations       []*PvzRepositoryMockCreateReceptionExpectation

	callArgs []*PvzRepositoryMockCreateReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockCreateReceptionExpectation specifies expectation struct of the PvzRepository.CreateReception
type PvzRepositoryMockCreateReceptionExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockCreateReceptionParams
	paramPtrs          *PvzRepositoryMockCreateReceptionParamPtrs
	expectationOrigins PvzRepositoryMockCreateReceptionExpectationOrigins
	results            *PvzRepositoryMockCreateReceptionResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockCreateReceptionParams contains parameters of the PvzRepository.CreateReception
type PvzRepositoryMockCreateReceptionParams struct {
	ctx   context.Context
	pvzId uuid.UUID
}

// PvzRepositoryMockCreateReceptionParamPtrs contains pointers to parameters of the PvzRepository.CreateReception
type PvzRepositoryMockCreateReceptionParamPtrs struct {
	ctx   *context.Context
	pvzId *uuid.UUID
}

// PvzRepositoryMockCreateReceptionResults contains results of the PvzRepository.CreateReception
type PvzRepositoryMockCreateReceptionResults struct {
	rp1 *model.Reception
	err error
}

// PvzRepositoryMockCreateReceptionOrigins contains origins of expectations of the PvzRepository.CreateReception
type PvzRepositoryMockCreateReceptionExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCreateReception *mPvzRepositoryMockCreateReception) Optional() *mPvzRepositoryMockCreateReception {
	mmCreateReception.optional = true
	return mmCreateReception
}

// Expect sets up expected params for PvzRepository.CreateReception
func (mmCreateReception *mPvzRepositoryMockCreateReception) Expect(ctx context.Context, pvzId uuid.UUID) *mPvzRepositoryMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &PvzRepositoryMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.paramPtrs != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by ExpectParams functions")
	}

	mmCreateReception.defaultExpectation.params = &PvzRepositoryMockCreateReceptionParams{ctx, pvzId}
	mmCreateReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCreateReception.expectations {
		if minimock.Equal(e.params, mmCreateReception.defaultExpectation.params) {
			mmCreateReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCreateReception.defaultExpectation.params)
		}
	}

	return mmCreateReception
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.CreateReception
func (mmCreateReception *mPvzRepositoryMockCreateReception) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &PvzRepositoryMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.params != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Expect")
	}

	if mmCreateReception.defaultExpectation.paramPtrs == nil {
		mmCreateReception.defaultExpectation.paramPtrs = &PvzRepositoryMockCreateReceptionParamPtrs{}
	}
	mmCreateReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmCreateReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCreateReception
}

// ExpectPvzIdParam2 sets up expected param pvzId for PvzRepository.CreateReception
func (mmCreateReception *mPvzRepositoryMockCreateReception) ExpectPvzIdParam2(pvzId uuid.UUID) *mPvzRepositoryMockCreateReception {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &PvzRepositoryMockCreateReceptionExpectation{}
	}

	if mmCreateReception.defaultExpectation.params != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Expect")
	}

	if mmCreateReception.defaultExpectation.paramPtrs == nil {
		mmCreateReception.defaultExpectation.paramPtrs = &PvzRepositoryMockCreateReceptionParamPtrs{}
	}
	mmCreateReception.defaultExpectation.paramPtrs.pvzId = &pvzId
	mmCreateReception.defaultExpectation.expectationOrigins.originPvzId = minimock.CallerInfo(1)

	return mmCreateReception
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.CreateReception
func (mmCreateReception *mPvzRepositoryMockCreateReception) Inspect(f func(ctx context.Context, pvzId uuid.UUID)) *mPvzRepositoryMockCreateReception {
	if mmCreateReception.mock.inspectFuncCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.CreateReception")
	}

	mmCreateReception.mock.inspectFuncCreateReception = f

	return mmCreateReception
}

// Return sets up results that will be returned by PvzRepository.CreateReception
func (mmCreateReception *mPvzRepositoryMockCreateReception) Return(rp1 *model.Reception, err error) *PvzRepositoryMock {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Set")
	}

	if mmCreateReception.defaultExpectation == nil {
		mmCreateReception.defaultExpectation = &PvzRepositoryMockCreateReceptionExpectation{mock: mmCreateReception.mock}
	}
	mmCreateReception.defaultExpectation.results = &PvzRepositoryMockCreateReceptionResults{rp1, err}
	mmCreateReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCreateReception.mock
}

// Set uses given function f to mock the PvzRepository.CreateReception method
func (mmCreateReception *mPvzRepositoryMockCreateReception) Set(f func(ctx context.Context, pvzId uuid.UUID) (rp1 *model.Reception, err error)) *PvzRepositoryMock {
	if mmCreateReception.defaultExpectation != nil {
		mmCreateReception.mock.t.Fatalf("Default expectation is already set for the PvzRepository.CreateReception method")
	}

	if len(mmCreateReception.expectations) > 0 {
		mmCreateReception.mock.t.Fatalf("Some expectations are already set for the PvzRepository.CreateReception method")
	}

	mmCreateReception.mock.funcCreateReception = f
	mmCreateReception.mock.funcCreateReceptionOrigin = minimock.CallerInfo(1)
	return mmCreateReception.mock
}

// When sets expectation for the PvzRepository.CreateReception which will trigger the result defined by the following
// Then helper
func (mmCreateReception *mPvzRepositoryMockCreateReception) When(ctx context.Context, pvzId uuid.UUID) *PvzRepositoryMockCreateReceptionExpectation {
	if mmCreateReception.mock.funcCreateReception != nil {
		mmCreateReception.mock.t.Fatalf("PvzRepositoryMock.CreateReception mock is already set by Set")
	}

	expectation := &PvzRepositoryMockCreateReceptionExpectation{
		mock:               mmCreateReception.mock,
		params:             &PvzRepositoryMockCreateReceptionParams{ctx, pvzId},
		expectationOrigins: PvzRepositoryMockCreateReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCreateReception.expectations = append(mmCreateReception.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.CreateReception return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockCreateReceptionExpectation) Then(rp1 *model.Reception, err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockCreateReceptionResults{rp1, err}
	return e.mock
}

// Times sets number of times PvzRepository.CreateReception should be invoked
func (mmCreateReception *mPvzRepositoryMockCreateReception) Times(n uint64) *mPvzRepositoryMockCreateReception {
	if n == 0 {
		mmCreateReception.mock.t.Fatalf("Times of PvzRepositoryMock.CreateReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCreateReception.expectedInvocations, n)
	mmCreateReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCreateReception
}

func (mmCreateReception *mPvzRepositoryMockCreateReception) invocationsDone() bool {
	if len(mmCreateReception.expectations) == 0 && mmCreateReception.defaultExpectation == nil && mmCreateReception.mock.funcCreateReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCreateReception.mock.afterCreateReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCreateReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// CreateReception implements mm_repository.PvzRepository
func (mmCreateReception *PvzRepositoryMock) CreateReception(ctx context.Context, pvzId uuid.UUID) (rp1 *model.Reception, err error) {
	mm_atomic.AddUint64(&mmCreateReception.beforeCreateReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmCreateReception.afterCreateReceptionCounter, 1)

	mmCreateReception.t.Helper()

	if mmCreateReception.inspectFuncCreateReception != nil {
		mmCreateReception.inspectFuncCreateReception(ctx, pvzId)
	}

	mm_params := PvzRepositoryMockCreateReceptionParams{ctx, pvzId}

	// Record call args
	mmCreateReception.CreateReceptionMock.mutex.Lock()
	mmCreateReception.CreateReceptionMock.callArgs = append(mmCreateReception.CreateReceptionMock.callArgs, &mm_params)
	mmCreateReception.CreateReceptionMock.mutex.Unlock()

	for _, e := range mmCreateReception.CreateReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmCreateReception.CreateReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCreateReception.CreateReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmCreateReception.CreateReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmCreateReception.CreateReceptionMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockCreateReceptionParams{ctx, pvzId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCreateReception.t.Errorf("PvzRepositoryMock.CreateReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzId != nil && !minimock.Equal(*mm_want_ptrs.pvzId, mm_got.pvzId) {
				mmCreateReception.t.Errorf("PvzRepositoryMock.CreateReception got unexpected parameter pvzId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.originPvzId, *mm_want_ptrs.pvzId, mm_got.pvzId, minimock.Diff(*mm_want_ptrs.pvzId, mm_got.pvzId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCreateReception.t.Errorf("PvzRepositoryMock.CreateReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCreateReception.CreateReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCreateReception.CreateReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmCreateReception.t.Fatal("No results are set for the PvzRepositoryMock.CreateReception")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmCreateReception.funcCreateReception != nil {
		return mmCreateReception.funcCreateReception(ctx, pvzId)
	}
	mmCreateReception.t.Fatalf("Unexpected call to PvzRepositoryMock.CreateReception. %v %v", ctx, pvzId)
	return
}

// CreateReceptionAfterCounter returns a count of finished PvzRepositoryMock.CreateReception invocations
func (mmCreateReception *PvzRepositoryMock) CreateReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReception.afterCreateReceptionCounter)
}

// CreateReceptionBeforeCounter returns a count of PvzRepositoryMock.CreateReception invocations
func (mmCreateReception *PvzRepositoryMock) CreateReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCreateReception.beforeCreateReceptionCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.CreateReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCreateReception *mPvzRepositoryMockCreateReception) Calls() []*PvzRepositoryMockCreateReceptionParams {
	mmCreateReception.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockCreateReceptionParams, len(mmCreateReception.callArgs))
	copy(argCopy, mmCreateReception.callArgs)

	mmCreateReception.mutex.RUnlock()

	return argCopy
}

// MinimockCreateReceptionDone returns true if the count of the CreateReception invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockCreateReceptionDone() bool {
	if m.CreateReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CreateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CreateReceptionMock.invocationsDone()
}

// MinimockCreateReceptionInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockCreateReceptionInspect() {
	for _, e := range m.CreateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.CreateReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCreateReceptionCounter := mm_atomic.LoadUint64(&m.afterCreateReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CreateReceptionMock.defaultExpectation != nil && afterCreateReceptionCounter < 1 {
		if m.CreateReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.CreateReception at\n%s", m.CreateReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.CreateReception at\n%s with params: %#v", m.CreateReceptionMock.defaultExpectation.expectationOrigins.origin, *m.CreateReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCreateReception != nil && afterCreateReceptionCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.CreateReception at\n%s", m.funcCreateReceptionOrigin)
	}

	if !m.CreateReceptionMock.invocationsDone() && afterCreateReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.CreateReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CreateReceptionMock.expectedInvocations), m.CreateReceptionMock.expectedInvocationsOrigin, afterCreateReceptionCounter)
	}
}

type mPvzRepositoryMockDeleteLastProduct struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockDeleteLastProductExpectation
	expectations       []*PvzRepositoryMockDeleteLastProductExpectation

	callArgs []*PvzRepositoryMockDeleteLastProductParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockDeleteLastProductExpectation specifies expectation struct of the PvzRepository.DeleteLastProduct
type PvzRepositoryMockDeleteLastProductExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockDeleteLastProductParams
	paramPtrs          *PvzRepositoryMockDeleteLastProductParamPtrs
	expectationOrigins PvzRepositoryMockDeleteLastProductExpectationOrigins
	results            *PvzRepositoryMockDeleteLastProductResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockDeleteLastProductParams contains parameters of the PvzRepository.DeleteLastProduct
type PvzRepositoryMockDeleteLastProductParams struct {
	ctx         context.Context
	receptionId uuid.UUID
}

// PvzRepositoryMockDeleteLastProductParamPtrs contains pointers to parameters of the PvzRepository.DeleteLastProduct
type PvzRepositoryMockDeleteLastProductParamPtrs struct {
	ctx         *context.Context
	receptionId *uuid.UUID
}

// PvzRepositoryMockDeleteLastProductResults contains results of the PvzRepository.DeleteLastProduct
type PvzRepositoryMockDeleteLastProductResults struct {
	err error
}

// PvzRepositoryMockDeleteLastProductOrigins contains origins of expectations of the PvzRepository.DeleteLastProduct
type PvzRepositoryMockDeleteLastProductExpectationOrigins struct {
	origin            string
	originCtx         string
	originReceptionId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Optional() *mPvzRepositoryMockDeleteLastProduct {
	mmDeleteLastProduct.optional = true
	return mmDeleteLastProduct
}

// Expect sets up expected params for PvzRepository.DeleteLastProduct
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Expect(ctx context.Context, receptionId uuid.UUID) *mPvzRepositoryMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &PvzRepositoryMockDeleteLastProductExpectation{}
	}

	if mmDeleteLastProduct.defaultExpectation.paramPtrs != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by ExpectParams functions")
	}

	mmDeleteLastProduct.defaultExpectation.params = &PvzRepositoryMockDeleteLastProductParams{ctx, receptionId}
	mmDeleteLastProduct.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDeleteLastProduct.expectations {
		if minimock.Equal(e.params, mmDeleteLastProduct.defaultExpectation.params) {
			mmDeleteLastProduct.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDeleteLastProduct.defaultExpectation.params)
		}
	}

	return mmDeleteLastProduct
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.DeleteLastProduct
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &PvzRepositoryMockDeleteLastProductExpectation{}
	}

	if mmDeleteLastProduct.defaultExpectation.params != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Expect")
	}

	if mmDeleteLastProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteLastProduct.defaultExpectation.paramPtrs = &PvzRepositoryMockDeleteLastProductParamPtrs{}
	}
	mmDeleteLastProduct.defaultExpectation.paramPtrs.ctx = &ctx
	mmDeleteLastProduct.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDeleteLastProduct
}

// ExpectReceptionIdParam2 sets up expected param receptionId for PvzRepository.DeleteLastProduct
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) ExpectReceptionIdParam2(receptionId uuid.UUID) *mPvzRepositoryMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &PvzRepositoryMockDeleteLastProductExpectation{}
	}

	if mmDeleteLastProduct.defaultExpectation.params != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Expect")
	}

	if mmDeleteLastProduct.defaultExpectation.paramPtrs == nil {
		mmDeleteLastProduct.defaultExpectation.paramPtrs = &PvzRepositoryMockDeleteLastProductParamPtrs{}
	}
	mmDeleteLastProduct.defaultExpectation.paramPtrs.receptionId = &receptionId
	mmDeleteLastProduct.defaultExpectation.expectationOrigins.originReceptionId = minimock.CallerInfo(1)

	return mmDeleteLastProduct
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.DeleteLastProduct
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Inspect(f func(ctx context.Context, receptionId uuid.UUID)) *mPvzRepositoryMockDeleteLastProduct {
	if mmDeleteLastProduct.mock.inspectFuncDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.DeleteLastProduct")
	}

	mmDeleteLastProduct.mock.inspectFuncDeleteLastProduct = f

	return mmDeleteLastProduct
}

// Return sets up results that will be returned by PvzRepository.DeleteLastProduct
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Return(err error) *PvzRepositoryMock {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Set")
	}

	if mmDeleteLastProduct.defaultExpectation == nil {
		mmDeleteLastProduct.defaultExpectation = &PvzRepositoryMockDeleteLastProductExpectation{mock: mmDeleteLastProduct.mock}
	}
	mmDeleteLastProduct.defaultExpectation.results = &PvzRepositoryMockDeleteLastProductResults{err}
	mmDeleteLastProduct.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProduct.mock
}

// Set uses given function f to mock the PvzRepository.DeleteLastProduct method
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Set(f func(ctx context.Context, receptionId uuid.UUID) (err error)) *PvzRepositoryMock {
	if mmDeleteLastProduct.defaultExpectation != nil {
		mmDeleteLastProduct.mock.t.Fatalf("Default expectation is already set for the PvzRepository.DeleteLastProduct method")
	}

	if len(mmDeleteLastProduct.expectations) > 0 {
		mmDeleteLastProduct.mock.t.Fatalf("Some expectations are already set for the PvzRepository.DeleteLastProduct method")
	}

	mmDeleteLastProduct.mock.funcDeleteLastProduct = f
	mmDeleteLastProduct.mock.funcDeleteLastProductOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProduct.mock
}

// When sets expectation for the PvzRepository.DeleteLastProduct which will trigger the result defined by the following
// Then helper
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) When(ctx context.Context, receptionId uuid.UUID) *PvzRepositoryMockDeleteLastProductExpectation {
	if mmDeleteLastProduct.mock.funcDeleteLastProduct != nil {
		mmDeleteLastProduct.mock.t.Fatalf("PvzRepositoryMock.DeleteLastProduct mock is already set by Set")
	}

	expectation := &PvzRepositoryMockDeleteLastProductExpectation{
		mock:               mmDeleteLastProduct.mock,
		params:             &PvzRepositoryMockDeleteLastProductParams{ctx, receptionId},
		expectationOrigins: PvzRepositoryMockDeleteLastProductExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDeleteLastProduct.expectations = append(mmDeleteLastProduct.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.DeleteLastProduct return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockDeleteLastProductExpectation) Then(err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockDeleteLastProductResults{err}
	return e.mock
}

// Times sets number of times PvzRepository.DeleteLastProduct should be invoked
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Times(n uint64) *mPvzRepositoryMockDeleteLastProduct {
	if n == 0 {
		mmDeleteLastProduct.mock.t.Fatalf("Times of PvzRepositoryMock.DeleteLastProduct mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDeleteLastProduct.expectedInvocations, n)
	mmDeleteLastProduct.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDeleteLastProduct
}

func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) invocationsDone() bool {
	if len(mmDeleteLastProduct.expectations) == 0 && mmDeleteLastProduct.defaultExpectation == nil && mmDeleteLastProduct.mock.funcDeleteLastProduct == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDeleteLastProduct.mock.afterDeleteLastProductCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDeleteLastProduct.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DeleteLastProduct implements mm_repository.PvzRepository
func (mmDeleteLastProduct *PvzRepositoryMock) DeleteLastProduct(ctx context.Context, receptionId uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmDeleteLastProduct.beforeDeleteLastProductCounter, 1)
	defer mm_atomic.AddUint64(&mmDeleteLastProduct.afterDeleteLastProductCounter, 1)

	mmDeleteLastProduct.t.Helper()

	if mmDeleteLastProduct.inspectFuncDeleteLastProduct != nil {
		mmDeleteLastProduct.inspectFuncDeleteLastProduct(ctx, receptionId)
	}

	mm_params := PvzRepositoryMockDeleteLastProductParams{ctx, receptionId}

	// Record call args
	mmDeleteLastProduct.DeleteLastProductMock.mutex.Lock()
	mmDeleteLastProduct.DeleteLastProductMock.callArgs = append(mmDeleteLastProduct.DeleteLastProductMock.callArgs, &mm_params)
	mmDeleteLastProduct.DeleteLastProductMock.mutex.Unlock()

	for _, e := range mmDeleteLastProduct.DeleteLastProductMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.Counter, 1)
		mm_want := mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.params
		mm_want_ptrs := mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockDeleteLastProductParams{ctx, receptionId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDeleteLastProduct.t.Errorf("PvzRepositoryMock.DeleteLastProduct got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.receptionId != nil && !minimock.Equal(*mm_want_ptrs.receptionId, mm_got.receptionId) {
				mmDeleteLastProduct.t.Errorf("PvzRepositoryMock.DeleteLastProduct got unexpected parameter receptionId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.expectationOrigins.originReceptionId, *mm_want_ptrs.receptionId, mm_got.receptionId, minimock.Diff(*mm_want_ptrs.receptionId, mm_got.receptionId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDeleteLastProduct.t.Errorf("PvzRepositoryMock.DeleteLastProduct got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDeleteLastProduct.DeleteLastProductMock.defaultExpectation.results
		if mm_results == nil {
			mmDeleteLastProduct.t.Fatal("No results are set for the PvzRepositoryMock.DeleteLastProduct")
		}
		return (*mm_results).err
	}
	if mmDeleteLastProduct.funcDeleteLastProduct != nil {
		return mmDeleteLastProduct.funcDeleteLastProduct(ctx, receptionId)
	}
	mmDeleteLastProduct.t.Fatalf("Unexpected call to PvzRepositoryMock.DeleteLastProduct. %v %v", ctx, receptionId)
	return
}

// DeleteLastProductAfterCounter returns a count of finished PvzRepositoryMock.DeleteLastProduct invocations
func (mmDeleteLastProduct *PvzRepositoryMock) DeleteLastProductAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLastProduct.afterDeleteLastProductCounter)
}

// DeleteLastProductBeforeCounter returns a count of PvzRepositoryMock.DeleteLastProduct invocations
func (mmDeleteLastProduct *PvzRepositoryMock) DeleteLastProductBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDeleteLastProduct.beforeDeleteLastProductCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.DeleteLastProduct.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDeleteLastProduct *mPvzRepositoryMockDeleteLastProduct) Calls() []*PvzRepositoryMockDeleteLastProductParams {
	mmDeleteLastProduct.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockDeleteLastProductParams, len(mmDeleteLastProduct.callArgs))
	copy(argCopy, mmDeleteLastProduct.callArgs)

	mmDeleteLastProduct.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteLastProductDone returns true if the count of the DeleteLastProduct invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockDeleteLastProductDone() bool {
	if m.DeleteLastProductMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DeleteLastProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DeleteLastProductMock.invocationsDone()
}

// MinimockDeleteLastProductInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockDeleteLastProductInspect() {
	for _, e := range m.DeleteLastProductMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.DeleteLastProduct at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDeleteLastProductCounter := mm_atomic.LoadUint64(&m.afterDeleteLastProductCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteLastProductMock.defaultExpectation != nil && afterDeleteLastProductCounter < 1 {
		if m.DeleteLastProductMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.DeleteLastProduct at\n%s", m.DeleteLastProductMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.DeleteLastProduct at\n%s with params: %#v", m.DeleteLastProductMock.defaultExpectation.expectationOrigins.origin, *m.DeleteLastProductMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDeleteLastProduct != nil && afterDeleteLastProductCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.DeleteLastProduct at\n%s", m.funcDeleteLastProductOrigin)
	}

	if !m.DeleteLastProductMock.invocationsDone() && afterDeleteLastProductCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.DeleteLastProduct at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DeleteLastProductMock.expectedInvocations), m.DeleteLastProductMock.expectedInvocationsOrigin, afterDeleteLastProductCounter)
	}
}

type mPvzRepositoryMockGetLastReception struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockGetLastReceptionExpectation
	expectations       []*PvzRepositoryMockGetLastReceptionExpectation

	callArgs []*PvzRepositoryMockGetLastReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockGetLastReceptionExpectation specifies expectation struct of the PvzRepository.GetLastReception
type PvzRepositoryMockGetLastReceptionExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockGetLastReceptionParams
	paramPtrs          *PvzRepositoryMockGetLastReceptionParamPtrs
	expectationOrigins PvzRepositoryMockGetLastReceptionExpectationOrigins
	results            *PvzRepositoryMockGetLastReceptionResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockGetLastReceptionParams contains parameters of the PvzRepository.GetLastReception
type PvzRepositoryMockGetLastReceptionParams struct {
	ctx   context.Context
	pvzId uuid.UUID
}

// PvzRepositoryMockGetLastReceptionParamPtrs contains pointers to parameters of the PvzRepository.GetLastReception
type PvzRepositoryMockGetLastReceptionParamPtrs struct {
	ctx   *context.Context
	pvzId *uuid.UUID
}

// PvzRepositoryMockGetLastReceptionResults contains results of the PvzRepository.GetLastReception
type PvzRepositoryMockGetLastReceptionResults struct {
	rp1 *model.Reception
	err error
}

// PvzRepositoryMockGetLastReceptionOrigins contains origins of expectations of the PvzRepository.GetLastReception
type PvzRepositoryMockGetLastReceptionExpectationOrigins struct {
	origin      string
	originCtx   string
	originPvzId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Optional() *mPvzRepositoryMockGetLastReception {
	mmGetLastReception.optional = true
	return mmGetLastReception
}

// Expect sets up expected params for PvzRepository.GetLastReception
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Expect(ctx context.Context, pvzId uuid.UUID) *mPvzRepositoryMockGetLastReception {
	if mmGetLastReception.mock.funcGetLastReception != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Set")
	}

	if mmGetLastReception.defaultExpectation == nil {
		mmGetLastReception.defaultExpectation = &PvzRepositoryMockGetLastReceptionExpectation{}
	}

	if mmGetLastReception.defaultExpectation.paramPtrs != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by ExpectParams functions")
	}

	mmGetLastReception.defaultExpectation.params = &PvzRepositoryMockGetLastReceptionParams{ctx, pvzId}
	mmGetLastReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetLastReception.expectations {
		if minimock.Equal(e.params, mmGetLastReception.defaultExpectation.params) {
			mmGetLastReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetLastReception.defaultExpectation.params)
		}
	}

	return mmGetLastReception
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.GetLastReception
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockGetLastReception {
	if mmGetLastReception.mock.funcGetLastReception != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Set")
	}

	if mmGetLastReception.defaultExpectation == nil {
		mmGetLastReception.defaultExpectation = &PvzRepositoryMockGetLastReceptionExpectation{}
	}

	if mmGetLastReception.defaultExpectation.params != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Expect")
	}

	if mmGetLastReception.defaultExpectation.paramPtrs == nil {
		mmGetLastReception.defaultExpectation.paramPtrs = &PvzRepositoryMockGetLastReceptionParamPtrs{}
	}
	mmGetLastReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetLastReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetLastReception
}

// ExpectPvzIdParam2 sets up expected param pvzId for PvzRepository.GetLastReception
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) ExpectPvzIdParam2(pvzId uuid.UUID) *mPvzRepositoryMockGetLastReception {
	if mmGetLastReception.mock.funcGetLastReception != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Set")
	}

	if mmGetLastReception.defaultExpectation == nil {
		mmGetLastReception.defaultExpectation = &PvzRepositoryMockGetLastReceptionExpectation{}
	}

	if mmGetLastReception.defaultExpectation.params != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Expect")
	}

	if mmGetLastReception.defaultExpectation.paramPtrs == nil {
		mmGetLastReception.defaultExpectation.paramPtrs = &PvzRepositoryMockGetLastReceptionParamPtrs{}
	}
	mmGetLastReception.defaultExpectation.paramPtrs.pvzId = &pvzId
	mmGetLastReception.defaultExpectation.expectationOrigins.originPvzId = minimock.CallerInfo(1)

	return mmGetLastReception
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.GetLastReception
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Inspect(f func(ctx context.Context, pvzId uuid.UUID)) *mPvzRepositoryMockGetLastReception {
	if mmGetLastReception.mock.inspectFuncGetLastReception != nil {
		mmGetLastReception.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.GetLastReception")
	}

	mmGetLastReception.mock.inspectFuncGetLastReception = f

	return mmGetLastReception
}

// Return sets up results that will be returned by PvzRepository.GetLastReception
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Return(rp1 *model.Reception, err error) *PvzRepositoryMock {
	if mmGetLastReception.mock.funcGetLastReception != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Set")
	}

	if mmGetLastReception.defaultExpectation == nil {
		mmGetLastReception.defaultExpectation = &PvzRepositoryMockGetLastReceptionExpectation{mock: mmGetLastReception.mock}
	}
	mmGetLastReception.defaultExpectation.results = &PvzRepositoryMockGetLastReceptionResults{rp1, err}
	mmGetLastReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetLastReception.mock
}

// Set uses given function f to mock the PvzRepository.GetLastReception method
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Set(f func(ctx context.Context, pvzId uuid.UUID) (rp1 *model.Reception, err error)) *PvzRepositoryMock {
	if mmGetLastReception.defaultExpectation != nil {
		mmGetLastReception.mock.t.Fatalf("Default expectation is already set for the PvzRepository.GetLastReception method")
	}

	if len(mmGetLastReception.expectations) > 0 {
		mmGetLastReception.mock.t.Fatalf("Some expectations are already set for the PvzRepository.GetLastReception method")
	}

	mmGetLastReception.mock.funcGetLastReception = f
	mmGetLastReception.mock.funcGetLastReceptionOrigin = minimock.CallerInfo(1)
	return mmGetLastReception.mock
}

// When sets expectation for the PvzRepository.GetLastReception which will trigger the result defined by the following
// Then helper
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) When(ctx context.Context, pvzId uuid.UUID) *PvzRepositoryMockGetLastReceptionExpectation {
	if mmGetLastReception.mock.funcGetLastReception != nil {
		mmGetLastReception.mock.t.Fatalf("PvzRepositoryMock.GetLastReception mock is already set by Set")
	}

	expectation := &PvzRepositoryMockGetLastReceptionExpectation{
		mock:               mmGetLastReception.mock,
		params:             &PvzRepositoryMockGetLastReceptionParams{ctx, pvzId},
		expectationOrigins: PvzRepositoryMockGetLastReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetLastReception.expectations = append(mmGetLastReception.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.GetLastReception return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockGetLastReceptionExpectation) Then(rp1 *model.Reception, err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockGetLastReceptionResults{rp1, err}
	return e.mock
}

// Times sets number of times PvzRepository.GetLastReception should be invoked
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Times(n uint64) *mPvzRepositoryMockGetLastReception {
	if n == 0 {
		mmGetLastReception.mock.t.Fatalf("Times of PvzRepositoryMock.GetLastReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetLastReception.expectedInvocations, n)
	mmGetLastReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetLastReception
}

func (mmGetLastReception *mPvzRepositoryMockGetLastReception) invocationsDone() bool {
	if len(mmGetLastReception.expectations) == 0 && mmGetLastReception.defaultExpectation == nil && mmGetLastReception.mock.funcGetLastReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetLastReception.mock.afterGetLastReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetLastReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetLastReception implements mm_repository.PvzRepository
func (mmGetLastReception *PvzRepositoryMock) GetLastReception(ctx context.Context, pvzId uuid.UUID) (rp1 *model.Reception, err error) {
	mm_atomic.AddUint64(&mmGetLastReception.beforeGetLastReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmGetLastReception.afterGetLastReceptionCounter, 1)

	mmGetLastReception.t.Helper()

	if mmGetLastReception.inspectFuncGetLastReception != nil {
		mmGetLastReception.inspectFuncGetLastReception(ctx, pvzId)
	}

	mm_params := PvzRepositoryMockGetLastReceptionParams{ctx, pvzId}

	// Record call args
	mmGetLastReception.GetLastReceptionMock.mutex.Lock()
	mmGetLastReception.GetLastReceptionMock.callArgs = append(mmGetLastReception.GetLastReceptionMock.callArgs, &mm_params)
	mmGetLastReception.GetLastReceptionMock.mutex.Unlock()

	for _, e := range mmGetLastReception.GetLastReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.rp1, e.results.err
		}
	}

	if mmGetLastReception.GetLastReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetLastReception.GetLastReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmGetLastReception.GetLastReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmGetLastReception.GetLastReceptionMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockGetLastReceptionParams{ctx, pvzId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetLastReception.t.Errorf("PvzRepositoryMock.GetLastReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLastReception.GetLastReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pvzId != nil && !minimock.Equal(*mm_want_ptrs.pvzId, mm_got.pvzId) {
				mmGetLastReception.t.Errorf("PvzRepositoryMock.GetLastReception got unexpected parameter pvzId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetLastReception.GetLastReceptionMock.defaultExpectation.expectationOrigins.originPvzId, *mm_want_ptrs.pvzId, mm_got.pvzId, minimock.Diff(*mm_want_ptrs.pvzId, mm_got.pvzId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetLastReception.t.Errorf("PvzRepositoryMock.GetLastReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetLastReception.GetLastReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetLastReception.GetLastReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmGetLastReception.t.Fatal("No results are set for the PvzRepositoryMock.GetLastReception")
		}
		return (*mm_results).rp1, (*mm_results).err
	}
	if mmGetLastReception.funcGetLastReception != nil {
		return mmGetLastReception.funcGetLastReception(ctx, pvzId)
	}
	mmGetLastReception.t.Fatalf("Unexpected call to PvzRepositoryMock.GetLastReception. %v %v", ctx, pvzId)
	return
}

// GetLastReceptionAfterCounter returns a count of finished PvzRepositoryMock.GetLastReception invocations
func (mmGetLastReception *PvzRepositoryMock) GetLastReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastReception.afterGetLastReceptionCounter)
}

// GetLastReceptionBeforeCounter returns a count of PvzRepositoryMock.GetLastReception invocations
func (mmGetLastReception *PvzRepositoryMock) GetLastReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetLastReception.beforeGetLastReceptionCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.GetLastReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetLastReception *mPvzRepositoryMockGetLastReception) Calls() []*PvzRepositoryMockGetLastReceptionParams {
	mmGetLastReception.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockGetLastReceptionParams, len(mmGetLastReception.callArgs))
	copy(argCopy, mmGetLastReception.callArgs)

	mmGetLastReception.mutex.RUnlock()

	return argCopy
}

// MinimockGetLastReceptionDone returns true if the count of the GetLastReception invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockGetLastReceptionDone() bool {
	if m.GetLastReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetLastReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetLastReceptionMock.invocationsDone()
}

// MinimockGetLastReceptionInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockGetLastReceptionInspect() {
	for _, e := range m.GetLastReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.GetLastReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetLastReceptionCounter := mm_atomic.LoadUint64(&m.afterGetLastReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetLastReceptionMock.defaultExpectation != nil && afterGetLastReceptionCounter < 1 {
		if m.GetLastReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.GetLastReception at\n%s", m.GetLastReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.GetLastReception at\n%s with params: %#v", m.GetLastReceptionMock.defaultExpectation.expectationOrigins.origin, *m.GetLastReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetLastReception != nil && afterGetLastReceptionCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.GetLastReception at\n%s", m.funcGetLastReceptionOrigin)
	}

	if !m.GetLastReceptionMock.invocationsDone() && afterGetLastReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.GetLastReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetLastReceptionMock.expectedInvocations), m.GetLastReceptionMock.expectedInvocationsOrigin, afterGetLastReceptionCounter)
	}
}

type mPvzRepositoryMockGetListPVZ struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockGetListPVZExpectation
	expectations       []*PvzRepositoryMockGetListPVZExpectation

	callArgs []*PvzRepositoryMockGetListPVZParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockGetListPVZExpectation specifies expectation struct of the PvzRepository.GetListPVZ
type PvzRepositoryMockGetListPVZExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockGetListPVZParams
	paramPtrs          *PvzRepositoryMockGetListPVZParamPtrs
	expectationOrigins PvzRepositoryMockGetListPVZExpectationOrigins
	results            *PvzRepositoryMockGetListPVZResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockGetListPVZParams contains parameters of the PvzRepository.GetListPVZ
type PvzRepositoryMockGetListPVZParams struct {
	ctx        context.Context
	pagination *model.Filter
}

// PvzRepositoryMockGetListPVZParamPtrs contains pointers to parameters of the PvzRepository.GetListPVZ
type PvzRepositoryMockGetListPVZParamPtrs struct {
	ctx        *context.Context
	pagination **model.Filter
}

// PvzRepositoryMockGetListPVZResults contains results of the PvzRepository.GetListPVZ
type PvzRepositoryMockGetListPVZResults struct {
	ppa1 []*model.PVZWithReceptions
	err  error
}

// PvzRepositoryMockGetListPVZOrigins contains origins of expectations of the PvzRepository.GetListPVZ
type PvzRepositoryMockGetListPVZExpectationOrigins struct {
	origin           string
	originCtx        string
	originPagination string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Optional() *mPvzRepositoryMockGetListPVZ {
	mmGetListPVZ.optional = true
	return mmGetListPVZ
}

// Expect sets up expected params for PvzRepository.GetListPVZ
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Expect(ctx context.Context, pagination *model.Filter) *mPvzRepositoryMockGetListPVZ {
	if mmGetListPVZ.mock.funcGetListPVZ != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Set")
	}

	if mmGetListPVZ.defaultExpectation == nil {
		mmGetListPVZ.defaultExpectation = &PvzRepositoryMockGetListPVZExpectation{}
	}

	if mmGetListPVZ.defaultExpectation.paramPtrs != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by ExpectParams functions")
	}

	mmGetListPVZ.defaultExpectation.params = &PvzRepositoryMockGetListPVZParams{ctx, pagination}
	mmGetListPVZ.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmGetListPVZ.expectations {
		if minimock.Equal(e.params, mmGetListPVZ.defaultExpectation.params) {
			mmGetListPVZ.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGetListPVZ.defaultExpectation.params)
		}
	}

	return mmGetListPVZ
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.GetListPVZ
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockGetListPVZ {
	if mmGetListPVZ.mock.funcGetListPVZ != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Set")
	}

	if mmGetListPVZ.defaultExpectation == nil {
		mmGetListPVZ.defaultExpectation = &PvzRepositoryMockGetListPVZExpectation{}
	}

	if mmGetListPVZ.defaultExpectation.params != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Expect")
	}

	if mmGetListPVZ.defaultExpectation.paramPtrs == nil {
		mmGetListPVZ.defaultExpectation.paramPtrs = &PvzRepositoryMockGetListPVZParamPtrs{}
	}
	mmGetListPVZ.defaultExpectation.paramPtrs.ctx = &ctx
	mmGetListPVZ.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmGetListPVZ
}

// ExpectPaginationParam2 sets up expected param pagination for PvzRepository.GetListPVZ
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) ExpectPaginationParam2(pagination *model.Filter) *mPvzRepositoryMockGetListPVZ {
	if mmGetListPVZ.mock.funcGetListPVZ != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Set")
	}

	if mmGetListPVZ.defaultExpectation == nil {
		mmGetListPVZ.defaultExpectation = &PvzRepositoryMockGetListPVZExpectation{}
	}

	if mmGetListPVZ.defaultExpectation.params != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Expect")
	}

	if mmGetListPVZ.defaultExpectation.paramPtrs == nil {
		mmGetListPVZ.defaultExpectation.paramPtrs = &PvzRepositoryMockGetListPVZParamPtrs{}
	}
	mmGetListPVZ.defaultExpectation.paramPtrs.pagination = &pagination
	mmGetListPVZ.defaultExpectation.expectationOrigins.originPagination = minimock.CallerInfo(1)

	return mmGetListPVZ
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.GetListPVZ
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Inspect(f func(ctx context.Context, pagination *model.Filter)) *mPvzRepositoryMockGetListPVZ {
	if mmGetListPVZ.mock.inspectFuncGetListPVZ != nil {
		mmGetListPVZ.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.GetListPVZ")
	}

	mmGetListPVZ.mock.inspectFuncGetListPVZ = f

	return mmGetListPVZ
}

// Return sets up results that will be returned by PvzRepository.GetListPVZ
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Return(ppa1 []*model.PVZWithReceptions, err error) *PvzRepositoryMock {
	if mmGetListPVZ.mock.funcGetListPVZ != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Set")
	}

	if mmGetListPVZ.defaultExpectation == nil {
		mmGetListPVZ.defaultExpectation = &PvzRepositoryMockGetListPVZExpectation{mock: mmGetListPVZ.mock}
	}
	mmGetListPVZ.defaultExpectation.results = &PvzRepositoryMockGetListPVZResults{ppa1, err}
	mmGetListPVZ.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetListPVZ.mock
}

// Set uses given function f to mock the PvzRepository.GetListPVZ method
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Set(f func(ctx context.Context, pagination *model.Filter) (ppa1 []*model.PVZWithReceptions, err error)) *PvzRepositoryMock {
	if mmGetListPVZ.defaultExpectation != nil {
		mmGetListPVZ.mock.t.Fatalf("Default expectation is already set for the PvzRepository.GetListPVZ method")
	}

	if len(mmGetListPVZ.expectations) > 0 {
		mmGetListPVZ.mock.t.Fatalf("Some expectations are already set for the PvzRepository.GetListPVZ method")
	}

	mmGetListPVZ.mock.funcGetListPVZ = f
	mmGetListPVZ.mock.funcGetListPVZOrigin = minimock.CallerInfo(1)
	return mmGetListPVZ.mock
}

// When sets expectation for the PvzRepository.GetListPVZ which will trigger the result defined by the following
// Then helper
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) When(ctx context.Context, pagination *model.Filter) *PvzRepositoryMockGetListPVZExpectation {
	if mmGetListPVZ.mock.funcGetListPVZ != nil {
		mmGetListPVZ.mock.t.Fatalf("PvzRepositoryMock.GetListPVZ mock is already set by Set")
	}

	expectation := &PvzRepositoryMockGetListPVZExpectation{
		mock:               mmGetListPVZ.mock,
		params:             &PvzRepositoryMockGetListPVZParams{ctx, pagination},
		expectationOrigins: PvzRepositoryMockGetListPVZExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmGetListPVZ.expectations = append(mmGetListPVZ.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.GetListPVZ return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockGetListPVZExpectation) Then(ppa1 []*model.PVZWithReceptions, err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockGetListPVZResults{ppa1, err}
	return e.mock
}

// Times sets number of times PvzRepository.GetListPVZ should be invoked
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Times(n uint64) *mPvzRepositoryMockGetListPVZ {
	if n == 0 {
		mmGetListPVZ.mock.t.Fatalf("Times of PvzRepositoryMock.GetListPVZ mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetListPVZ.expectedInvocations, n)
	mmGetListPVZ.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetListPVZ
}

func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) invocationsDone() bool {
	if len(mmGetListPVZ.expectations) == 0 && mmGetListPVZ.defaultExpectation == nil && mmGetListPVZ.mock.funcGetListPVZ == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetListPVZ.mock.afterGetListPVZCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetListPVZ.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetListPVZ implements mm_repository.PvzRepository
func (mmGetListPVZ *PvzRepositoryMock) GetListPVZ(ctx context.Context, pagination *model.Filter) (ppa1 []*model.PVZWithReceptions, err error) {
	mm_atomic.AddUint64(&mmGetListPVZ.beforeGetListPVZCounter, 1)
	defer mm_atomic.AddUint64(&mmGetListPVZ.afterGetListPVZCounter, 1)

	mmGetListPVZ.t.Helper()

	if mmGetListPVZ.inspectFuncGetListPVZ != nil {
		mmGetListPVZ.inspectFuncGetListPVZ(ctx, pagination)
	}

	mm_params := PvzRepositoryMockGetListPVZParams{ctx, pagination}

	// Record call args
	mmGetListPVZ.GetListPVZMock.mutex.Lock()
	mmGetListPVZ.GetListPVZMock.callArgs = append(mmGetListPVZ.GetListPVZMock.callArgs, &mm_params)
	mmGetListPVZ.GetListPVZMock.mutex.Unlock()

	for _, e := range mmGetListPVZ.GetListPVZMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ppa1, e.results.err
		}
	}

	if mmGetListPVZ.GetListPVZMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetListPVZ.GetListPVZMock.defaultExpectation.Counter, 1)
		mm_want := mmGetListPVZ.GetListPVZMock.defaultExpectation.params
		mm_want_ptrs := mmGetListPVZ.GetListPVZMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockGetListPVZParams{ctx, pagination}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmGetListPVZ.t.Errorf("PvzRepositoryMock.GetListPVZ got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListPVZ.GetListPVZMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.pagination != nil && !minimock.Equal(*mm_want_ptrs.pagination, mm_got.pagination) {
				mmGetListPVZ.t.Errorf("PvzRepositoryMock.GetListPVZ got unexpected parameter pagination, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmGetListPVZ.GetListPVZMock.defaultExpectation.expectationOrigins.originPagination, *mm_want_ptrs.pagination, mm_got.pagination, minimock.Diff(*mm_want_ptrs.pagination, mm_got.pagination))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGetListPVZ.t.Errorf("PvzRepositoryMock.GetListPVZ got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmGetListPVZ.GetListPVZMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGetListPVZ.GetListPVZMock.defaultExpectation.results
		if mm_results == nil {
			mmGetListPVZ.t.Fatal("No results are set for the PvzRepositoryMock.GetListPVZ")
		}
		return (*mm_results).ppa1, (*mm_results).err
	}
	if mmGetListPVZ.funcGetListPVZ != nil {
		return mmGetListPVZ.funcGetListPVZ(ctx, pagination)
	}
	mmGetListPVZ.t.Fatalf("Unexpected call to PvzRepositoryMock.GetListPVZ. %v %v", ctx, pagination)
	return
}

// GetListPVZAfterCounter returns a count of finished PvzRepositoryMock.GetListPVZ invocations
func (mmGetListPVZ *PvzRepositoryMock) GetListPVZAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListPVZ.afterGetListPVZCounter)
}

// GetListPVZBeforeCounter returns a count of PvzRepositoryMock.GetListPVZ invocations
func (mmGetListPVZ *PvzRepositoryMock) GetListPVZBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetListPVZ.beforeGetListPVZCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.GetListPVZ.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGetListPVZ *mPvzRepositoryMockGetListPVZ) Calls() []*PvzRepositoryMockGetListPVZParams {
	mmGetListPVZ.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockGetListPVZParams, len(mmGetListPVZ.callArgs))
	copy(argCopy, mmGetListPVZ.callArgs)

	mmGetListPVZ.mutex.RUnlock()

	return argCopy
}

// MinimockGetListPVZDone returns true if the count of the GetListPVZ invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockGetListPVZDone() bool {
	if m.GetListPVZMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetListPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetListPVZMock.invocationsDone()
}

// MinimockGetListPVZInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockGetListPVZInspect() {
	for _, e := range m.GetListPVZMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.GetListPVZ at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterGetListPVZCounter := mm_atomic.LoadUint64(&m.afterGetListPVZCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetListPVZMock.defaultExpectation != nil && afterGetListPVZCounter < 1 {
		if m.GetListPVZMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.GetListPVZ at\n%s", m.GetListPVZMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.GetListPVZ at\n%s with params: %#v", m.GetListPVZMock.defaultExpectation.expectationOrigins.origin, *m.GetListPVZMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetListPVZ != nil && afterGetListPVZCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.GetListPVZ at\n%s", m.funcGetListPVZOrigin)
	}

	if !m.GetListPVZMock.invocationsDone() && afterGetListPVZCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.GetListPVZ at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetListPVZMock.expectedInvocations), m.GetListPVZMock.expectedInvocationsOrigin, afterGetListPVZCounter)
	}
}

type mPvzRepositoryMockUpdateReception struct {
	optional           bool
	mock               *PvzRepositoryMock
	defaultExpectation *PvzRepositoryMockUpdateReceptionExpectation
	expectations       []*PvzRepositoryMockUpdateReceptionExpectation

	callArgs []*PvzRepositoryMockUpdateReceptionParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// PvzRepositoryMockUpdateReceptionExpectation specifies expectation struct of the PvzRepository.UpdateReception
type PvzRepositoryMockUpdateReceptionExpectation struct {
	mock               *PvzRepositoryMock
	params             *PvzRepositoryMockUpdateReceptionParams
	paramPtrs          *PvzRepositoryMockUpdateReceptionParamPtrs
	expectationOrigins PvzRepositoryMockUpdateReceptionExpectationOrigins
	results            *PvzRepositoryMockUpdateReceptionResults
	returnOrigin       string
	Counter            uint64
}

// PvzRepositoryMockUpdateReceptionParams contains parameters of the PvzRepository.UpdateReception
type PvzRepositoryMockUpdateReceptionParams struct {
	ctx         context.Context
	receptionId uuid.UUID
}

// PvzRepositoryMockUpdateReceptionParamPtrs contains pointers to parameters of the PvzRepository.UpdateReception
type PvzRepositoryMockUpdateReceptionParamPtrs struct {
	ctx         *context.Context
	receptionId *uuid.UUID
}

// PvzRepositoryMockUpdateReceptionResults contains results of the PvzRepository.UpdateReception
type PvzRepositoryMockUpdateReceptionResults struct {
	err error
}

// PvzRepositoryMockUpdateReceptionOrigins contains origins of expectations of the PvzRepository.UpdateReception
type PvzRepositoryMockUpdateReceptionExpectationOrigins struct {
	origin            string
	originCtx         string
	originReceptionId string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Optional() *mPvzRepositoryMockUpdateReception {
	mmUpdateReception.optional = true
	return mmUpdateReception
}

// Expect sets up expected params for PvzRepository.UpdateReception
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Expect(ctx context.Context, receptionId uuid.UUID) *mPvzRepositoryMockUpdateReception {
	if mmUpdateReception.mock.funcUpdateReception != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Set")
	}

	if mmUpdateReception.defaultExpectation == nil {
		mmUpdateReception.defaultExpectation = &PvzRepositoryMockUpdateReceptionExpectation{}
	}

	if mmUpdateReception.defaultExpectation.paramPtrs != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by ExpectParams functions")
	}

	mmUpdateReception.defaultExpectation.params = &PvzRepositoryMockUpdateReceptionParams{ctx, receptionId}
	mmUpdateReception.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateReception.expectations {
		if minimock.Equal(e.params, mmUpdateReception.defaultExpectation.params) {
			mmUpdateReception.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateReception.defaultExpectation.params)
		}
	}

	return mmUpdateReception
}

// ExpectCtxParam1 sets up expected param ctx for PvzRepository.UpdateReception
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) ExpectCtxParam1(ctx context.Context) *mPvzRepositoryMockUpdateReception {
	if mmUpdateReception.mock.funcUpdateReception != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Set")
	}

	if mmUpdateReception.defaultExpectation == nil {
		mmUpdateReception.defaultExpectation = &PvzRepositoryMockUpdateReceptionExpectation{}
	}

	if mmUpdateReception.defaultExpectation.params != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Expect")
	}

	if mmUpdateReception.defaultExpectation.paramPtrs == nil {
		mmUpdateReception.defaultExpectation.paramPtrs = &PvzRepositoryMockUpdateReceptionParamPtrs{}
	}
	mmUpdateReception.defaultExpectation.paramPtrs.ctx = &ctx
	mmUpdateReception.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmUpdateReception
}

// ExpectReceptionIdParam2 sets up expected param receptionId for PvzRepository.UpdateReception
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) ExpectReceptionIdParam2(receptionId uuid.UUID) *mPvzRepositoryMockUpdateReception {
	if mmUpdateReception.mock.funcUpdateReception != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Set")
	}

	if mmUpdateReception.defaultExpectation == nil {
		mmUpdateReception.defaultExpectation = &PvzRepositoryMockUpdateReceptionExpectation{}
	}

	if mmUpdateReception.defaultExpectation.params != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Expect")
	}

	if mmUpdateReception.defaultExpectation.paramPtrs == nil {
		mmUpdateReception.defaultExpectation.paramPtrs = &PvzRepositoryMockUpdateReceptionParamPtrs{}
	}
	mmUpdateReception.defaultExpectation.paramPtrs.receptionId = &receptionId
	mmUpdateReception.defaultExpectation.expectationOrigins.originReceptionId = minimock.CallerInfo(1)

	return mmUpdateReception
}

// Inspect accepts an inspector function that has same arguments as the PvzRepository.UpdateReception
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Inspect(f func(ctx context.Context, receptionId uuid.UUID)) *mPvzRepositoryMockUpdateReception {
	if mmUpdateReception.mock.inspectFuncUpdateReception != nil {
		mmUpdateReception.mock.t.Fatalf("Inspect function is already set for PvzRepositoryMock.UpdateReception")
	}

	mmUpdateReception.mock.inspectFuncUpdateReception = f

	return mmUpdateReception
}

// Return sets up results that will be returned by PvzRepository.UpdateReception
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Return(err error) *PvzRepositoryMock {
	if mmUpdateReception.mock.funcUpdateReception != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Set")
	}

	if mmUpdateReception.defaultExpectation == nil {
		mmUpdateReception.defaultExpectation = &PvzRepositoryMockUpdateReceptionExpectation{mock: mmUpdateReception.mock}
	}
	mmUpdateReception.defaultExpectation.results = &PvzRepositoryMockUpdateReceptionResults{err}
	mmUpdateReception.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateReception.mock
}

// Set uses given function f to mock the PvzRepository.UpdateReception method
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Set(f func(ctx context.Context, receptionId uuid.UUID) (err error)) *PvzRepositoryMock {
	if mmUpdateReception.defaultExpectation != nil {
		mmUpdateReception.mock.t.Fatalf("Default expectation is already set for the PvzRepository.UpdateReception method")
	}

	if len(mmUpdateReception.expectations) > 0 {
		mmUpdateReception.mock.t.Fatalf("Some expectations are already set for the PvzRepository.UpdateReception method")
	}

	mmUpdateReception.mock.funcUpdateReception = f
	mmUpdateReception.mock.funcUpdateReceptionOrigin = minimock.CallerInfo(1)
	return mmUpdateReception.mock
}

// When sets expectation for the PvzRepository.UpdateReception which will trigger the result defined by the following
// Then helper
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) When(ctx context.Context, receptionId uuid.UUID) *PvzRepositoryMockUpdateReceptionExpectation {
	if mmUpdateReception.mock.funcUpdateReception != nil {
		mmUpdateReception.mock.t.Fatalf("PvzRepositoryMock.UpdateReception mock is already set by Set")
	}

	expectation := &PvzRepositoryMockUpdateReceptionExpectation{
		mock:               mmUpdateReception.mock,
		params:             &PvzRepositoryMockUpdateReceptionParams{ctx, receptionId},
		expectationOrigins: PvzRepositoryMockUpdateReceptionExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateReception.expectations = append(mmUpdateReception.expectations, expectation)
	return expectation
}

// Then sets up PvzRepository.UpdateReception return parameters for the expectation previously defined by the When method
func (e *PvzRepositoryMockUpdateReceptionExpectation) Then(err error) *PvzRepositoryMock {
	e.results = &PvzRepositoryMockUpdateReceptionResults{err}
	return e.mock
}

// Times sets number of times PvzRepository.UpdateReception should be invoked
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Times(n uint64) *mPvzRepositoryMockUpdateReception {
	if n == 0 {
		mmUpdateReception.mock.t.Fatalf("Times of PvzRepositoryMock.UpdateReception mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateReception.expectedInvocations, n)
	mmUpdateReception.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateReception
}

func (mmUpdateReception *mPvzRepositoryMockUpdateReception) invocationsDone() bool {
	if len(mmUpdateReception.expectations) == 0 && mmUpdateReception.defaultExpectation == nil && mmUpdateReception.mock.funcUpdateReception == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateReception.mock.afterUpdateReceptionCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateReception.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateReception implements mm_repository.PvzRepository
func (mmUpdateReception *PvzRepositoryMock) UpdateReception(ctx context.Context, receptionId uuid.UUID) (err error) {
	mm_atomic.AddUint64(&mmUpdateReception.beforeUpdateReceptionCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateReception.afterUpdateReceptionCounter, 1)

	mmUpdateReception.t.Helper()

	if mmUpdateReception.inspectFuncUpdateReception != nil {
		mmUpdateReception.inspectFuncUpdateReception(ctx, receptionId)
	}

	mm_params := PvzRepositoryMockUpdateReceptionParams{ctx, receptionId}

	// Record call args
	mmUpdateReception.UpdateReceptionMock.mutex.Lock()
	mmUpdateReception.UpdateReceptionMock.callArgs = append(mmUpdateReception.UpdateReceptionMock.callArgs, &mm_params)
	mmUpdateReception.UpdateReceptionMock.mutex.Unlock()

	for _, e := range mmUpdateReception.UpdateReceptionMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateReception.UpdateReceptionMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateReception.UpdateReceptionMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateReception.UpdateReceptionMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateReception.UpdateReceptionMock.defaultExpectation.paramPtrs

		mm_got := PvzRepositoryMockUpdateReceptionParams{ctx, receptionId}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmUpdateReception.t.Errorf("PvzRepositoryMock.UpdateReception got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReception.UpdateReceptionMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.receptionId != nil && !minimock.Equal(*mm_want_ptrs.receptionId, mm_got.receptionId) {
				mmUpdateReception.t.Errorf("PvzRepositoryMock.UpdateReception got unexpected parameter receptionId, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateReception.UpdateReceptionMock.defaultExpectation.expectationOrigins.originReceptionId, *mm_want_ptrs.receptionId, mm_got.receptionId, minimock.Diff(*mm_want_ptrs.receptionId, mm_got.receptionId))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateReception.t.Errorf("PvzRepositoryMock.UpdateReception got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateReception.UpdateReceptionMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateReception.UpdateReceptionMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateReception.t.Fatal("No results are set for the PvzRepositoryMock.UpdateReception")
		}
		return (*mm_results).err
	}
	if mmUpdateReception.funcUpdateReception != nil {
		return mmUpdateReception.funcUpdateReception(ctx, receptionId)
	}
	mmUpdateReception.t.Fatalf("Unexpected call to PvzRepositoryMock.UpdateReception. %v %v", ctx, receptionId)
	return
}

// UpdateReceptionAfterCounter returns a count of finished PvzRepositoryMock.UpdateReception invocations
func (mmUpdateReception *PvzRepositoryMock) UpdateReceptionAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReception.afterUpdateReceptionCounter)
}

// UpdateReceptionBeforeCounter returns a count of PvzRepositoryMock.UpdateReception invocations
func (mmUpdateReception *PvzRepositoryMock) UpdateReceptionBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateReception.beforeUpdateReceptionCounter)
}

// Calls returns a list of arguments used in each call to PvzRepositoryMock.UpdateReception.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateReception *mPvzRepositoryMockUpdateReception) Calls() []*PvzRepositoryMockUpdateReceptionParams {
	mmUpdateReception.mutex.RLock()

	argCopy := make([]*PvzRepositoryMockUpdateReceptionParams, len(mmUpdateReception.callArgs))
	copy(argCopy, mmUpdateReception.callArgs)

	mmUpdateReception.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateReceptionDone returns true if the count of the UpdateReception invocations corresponds
// the number of defined expectations
func (m *PvzRepositoryMock) MinimockUpdateReceptionDone() bool {
	if m.UpdateReceptionMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateReceptionMock.invocationsDone()
}

// MinimockUpdateReceptionInspect logs each unmet expectation
func (m *PvzRepositoryMock) MinimockUpdateReceptionInspect() {
	for _, e := range m.UpdateReceptionMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to PvzRepositoryMock.UpdateReception at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateReceptionCounter := mm_atomic.LoadUint64(&m.afterUpdateReceptionCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateReceptionMock.defaultExpectation != nil && afterUpdateReceptionCounter < 1 {
		if m.UpdateReceptionMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to PvzRepositoryMock.UpdateReception at\n%s", m.UpdateReceptionMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to PvzRepositoryMock.UpdateReception at\n%s with params: %#v", m.UpdateReceptionMock.defaultExpectation.expectationOrigins.origin, *m.UpdateReceptionMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateReception != nil && afterUpdateReceptionCounter < 1 {
		m.t.Errorf("Expected call to PvzRepositoryMock.UpdateReception at\n%s", m.funcUpdateReceptionOrigin)
	}

	if !m.UpdateReceptionMock.invocationsDone() && afterUpdateReceptionCounter > 0 {
		m.t.Errorf("Expected %d calls to PvzRepositoryMock.UpdateReception at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateReceptionMock.expectedInvocations), m.UpdateReceptionMock.expectedInvocationsOrigin, afterUpdateReceptionCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *PvzRepositoryMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCreateInspect()

			m.MinimockCreateProductInspect()

			m.MinimockCreateReceptionInspect()

			m.MinimockDeleteLastProductInspect()

			m.MinimockGetLastReceptionInspect()

			m.MinimockGetListPVZInspect()

			m.MinimockUpdateReceptionInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *PvzRepositoryMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *PvzRepositoryMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCreateDone() &&
		m.MinimockCreateProductDone() &&
		m.MinimockCreateReceptionDone() &&
		m.MinimockDeleteLastProductDone() &&
		m.MinimockGetLastReceptionDone() &&
		m.MinimockGetListPVZDone() &&
		m.MinimockUpdateReceptionDone()
}
