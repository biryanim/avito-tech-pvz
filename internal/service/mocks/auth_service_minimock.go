// Code generated by http://github.com/gojuno/minimock (v3.4.3). DO NOT EDIT.

package mocks

//go:generate minimock -i github.com/biryanim/avito-tech-pvz/internal/service.AuthService -o auth_service_minimock.go -n AuthServiceMock -p mocks

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/biryanim/avito-tech-pvz/internal/model"
	"github.com/gojuno/minimock/v3"
)

// AuthServiceMock implements mm_service.AuthService
type AuthServiceMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcCheck          func(ctx context.Context, token string, method string, endpointAddress string) (b1 bool, err error)
	funcCheckOrigin    string
	inspectFuncCheck   func(ctx context.Context, token string, method string, endpointAddress string)
	afterCheckCounter  uint64
	beforeCheckCounter uint64
	CheckMock          mAuthServiceMockCheck

	funcDummyLogin          func(ctx context.Context, role model.Role) (s1 string, err error)
	funcDummyLoginOrigin    string
	inspectFuncDummyLogin   func(ctx context.Context, role model.Role)
	afterDummyLoginCounter  uint64
	beforeDummyLoginCounter uint64
	DummyLoginMock          mAuthServiceMockDummyLogin

	funcLogin          func(ctx context.Context, loginInfo *model.UserLoginInfo) (s1 string, err error)
	funcLoginOrigin    string
	inspectFuncLogin   func(ctx context.Context, loginInfo *model.UserLoginInfo)
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mAuthServiceMockLogin

	funcRegister          func(ctx context.Context, registerInfo *model.UserRegistration) (up1 *model.User, err error)
	funcRegisterOrigin    string
	inspectFuncRegister   func(ctx context.Context, registerInfo *model.UserRegistration)
	afterRegisterCounter  uint64
	beforeRegisterCounter uint64
	RegisterMock          mAuthServiceMockRegister
}

// NewAuthServiceMock returns a mock for mm_service.AuthService
func NewAuthServiceMock(t minimock.Tester) *AuthServiceMock {
	m := &AuthServiceMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.CheckMock = mAuthServiceMockCheck{mock: m}
	m.CheckMock.callArgs = []*AuthServiceMockCheckParams{}

	m.DummyLoginMock = mAuthServiceMockDummyLogin{mock: m}
	m.DummyLoginMock.callArgs = []*AuthServiceMockDummyLoginParams{}

	m.LoginMock = mAuthServiceMockLogin{mock: m}
	m.LoginMock.callArgs = []*AuthServiceMockLoginParams{}

	m.RegisterMock = mAuthServiceMockRegister{mock: m}
	m.RegisterMock.callArgs = []*AuthServiceMockRegisterParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mAuthServiceMockCheck struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockCheckExpectation
	expectations       []*AuthServiceMockCheckExpectation

	callArgs []*AuthServiceMockCheckParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockCheckExpectation specifies expectation struct of the AuthService.Check
type AuthServiceMockCheckExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockCheckParams
	paramPtrs          *AuthServiceMockCheckParamPtrs
	expectationOrigins AuthServiceMockCheckExpectationOrigins
	results            *AuthServiceMockCheckResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockCheckParams contains parameters of the AuthService.Check
type AuthServiceMockCheckParams struct {
	ctx             context.Context
	token           string
	method          string
	endpointAddress string
}

// AuthServiceMockCheckParamPtrs contains pointers to parameters of the AuthService.Check
type AuthServiceMockCheckParamPtrs struct {
	ctx             *context.Context
	token           *string
	method          *string
	endpointAddress *string
}

// AuthServiceMockCheckResults contains results of the AuthService.Check
type AuthServiceMockCheckResults struct {
	b1  bool
	err error
}

// AuthServiceMockCheckOrigins contains origins of expectations of the AuthService.Check
type AuthServiceMockCheckExpectationOrigins struct {
	origin                string
	originCtx             string
	originToken           string
	originMethod          string
	originEndpointAddress string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmCheck *mAuthServiceMockCheck) Optional() *mAuthServiceMockCheck {
	mmCheck.optional = true
	return mmCheck
}

// Expect sets up expected params for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) Expect(ctx context.Context, token string, method string, endpointAddress string) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.paramPtrs != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by ExpectParams functions")
	}

	mmCheck.defaultExpectation.params = &AuthServiceMockCheckParams{ctx, token, method, endpointAddress}
	mmCheck.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmCheck.expectations {
		if minimock.Equal(e.params, mmCheck.defaultExpectation.params) {
			mmCheck.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCheck.defaultExpectation.params)
		}
	}

	return mmCheck
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &AuthServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.ctx = &ctx
	mmCheck.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmCheck
}

// ExpectTokenParam2 sets up expected param token for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) ExpectTokenParam2(token string) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &AuthServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.token = &token
	mmCheck.defaultExpectation.expectationOrigins.originToken = minimock.CallerInfo(1)

	return mmCheck
}

// ExpectMethodParam3 sets up expected param method for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) ExpectMethodParam3(method string) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &AuthServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.method = &method
	mmCheck.defaultExpectation.expectationOrigins.originMethod = minimock.CallerInfo(1)

	return mmCheck
}

// ExpectEndpointAddressParam4 sets up expected param endpointAddress for AuthService.Check
func (mmCheck *mAuthServiceMockCheck) ExpectEndpointAddressParam4(endpointAddress string) *mAuthServiceMockCheck {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{}
	}

	if mmCheck.defaultExpectation.params != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Expect")
	}

	if mmCheck.defaultExpectation.paramPtrs == nil {
		mmCheck.defaultExpectation.paramPtrs = &AuthServiceMockCheckParamPtrs{}
	}
	mmCheck.defaultExpectation.paramPtrs.endpointAddress = &endpointAddress
	mmCheck.defaultExpectation.expectationOrigins.originEndpointAddress = minimock.CallerInfo(1)

	return mmCheck
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Check
func (mmCheck *mAuthServiceMockCheck) Inspect(f func(ctx context.Context, token string, method string, endpointAddress string)) *mAuthServiceMockCheck {
	if mmCheck.mock.inspectFuncCheck != nil {
		mmCheck.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Check")
	}

	mmCheck.mock.inspectFuncCheck = f

	return mmCheck
}

// Return sets up results that will be returned by AuthService.Check
func (mmCheck *mAuthServiceMockCheck) Return(b1 bool, err error) *AuthServiceMock {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	if mmCheck.defaultExpectation == nil {
		mmCheck.defaultExpectation = &AuthServiceMockCheckExpectation{mock: mmCheck.mock}
	}
	mmCheck.defaultExpectation.results = &AuthServiceMockCheckResults{b1, err}
	mmCheck.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmCheck.mock
}

// Set uses given function f to mock the AuthService.Check method
func (mmCheck *mAuthServiceMockCheck) Set(f func(ctx context.Context, token string, method string, endpointAddress string) (b1 bool, err error)) *AuthServiceMock {
	if mmCheck.defaultExpectation != nil {
		mmCheck.mock.t.Fatalf("Default expectation is already set for the AuthService.Check method")
	}

	if len(mmCheck.expectations) > 0 {
		mmCheck.mock.t.Fatalf("Some expectations are already set for the AuthService.Check method")
	}

	mmCheck.mock.funcCheck = f
	mmCheck.mock.funcCheckOrigin = minimock.CallerInfo(1)
	return mmCheck.mock
}

// When sets expectation for the AuthService.Check which will trigger the result defined by the following
// Then helper
func (mmCheck *mAuthServiceMockCheck) When(ctx context.Context, token string, method string, endpointAddress string) *AuthServiceMockCheckExpectation {
	if mmCheck.mock.funcCheck != nil {
		mmCheck.mock.t.Fatalf("AuthServiceMock.Check mock is already set by Set")
	}

	expectation := &AuthServiceMockCheckExpectation{
		mock:               mmCheck.mock,
		params:             &AuthServiceMockCheckParams{ctx, token, method, endpointAddress},
		expectationOrigins: AuthServiceMockCheckExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmCheck.expectations = append(mmCheck.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Check return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockCheckExpectation) Then(b1 bool, err error) *AuthServiceMock {
	e.results = &AuthServiceMockCheckResults{b1, err}
	return e.mock
}

// Times sets number of times AuthService.Check should be invoked
func (mmCheck *mAuthServiceMockCheck) Times(n uint64) *mAuthServiceMockCheck {
	if n == 0 {
		mmCheck.mock.t.Fatalf("Times of AuthServiceMock.Check mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmCheck.expectedInvocations, n)
	mmCheck.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmCheck
}

func (mmCheck *mAuthServiceMockCheck) invocationsDone() bool {
	if len(mmCheck.expectations) == 0 && mmCheck.defaultExpectation == nil && mmCheck.mock.funcCheck == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmCheck.mock.afterCheckCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmCheck.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Check implements mm_service.AuthService
func (mmCheck *AuthServiceMock) Check(ctx context.Context, token string, method string, endpointAddress string) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmCheck.beforeCheckCounter, 1)
	defer mm_atomic.AddUint64(&mmCheck.afterCheckCounter, 1)

	mmCheck.t.Helper()

	if mmCheck.inspectFuncCheck != nil {
		mmCheck.inspectFuncCheck(ctx, token, method, endpointAddress)
	}

	mm_params := AuthServiceMockCheckParams{ctx, token, method, endpointAddress}

	// Record call args
	mmCheck.CheckMock.mutex.Lock()
	mmCheck.CheckMock.callArgs = append(mmCheck.CheckMock.callArgs, &mm_params)
	mmCheck.CheckMock.mutex.Unlock()

	for _, e := range mmCheck.CheckMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmCheck.CheckMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCheck.CheckMock.defaultExpectation.Counter, 1)
		mm_want := mmCheck.CheckMock.defaultExpectation.params
		mm_want_ptrs := mmCheck.CheckMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockCheckParams{ctx, token, method, endpointAddress}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheck.CheckMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.token != nil && !minimock.Equal(*mm_want_ptrs.token, mm_got.token) {
				mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameter token, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheck.CheckMock.defaultExpectation.expectationOrigins.originToken, *mm_want_ptrs.token, mm_got.token, minimock.Diff(*mm_want_ptrs.token, mm_got.token))
			}

			if mm_want_ptrs.method != nil && !minimock.Equal(*mm_want_ptrs.method, mm_got.method) {
				mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameter method, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheck.CheckMock.defaultExpectation.expectationOrigins.originMethod, *mm_want_ptrs.method, mm_got.method, minimock.Diff(*mm_want_ptrs.method, mm_got.method))
			}

			if mm_want_ptrs.endpointAddress != nil && !minimock.Equal(*mm_want_ptrs.endpointAddress, mm_got.endpointAddress) {
				mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameter endpointAddress, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmCheck.CheckMock.defaultExpectation.expectationOrigins.originEndpointAddress, *mm_want_ptrs.endpointAddress, mm_got.endpointAddress, minimock.Diff(*mm_want_ptrs.endpointAddress, mm_got.endpointAddress))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCheck.t.Errorf("AuthServiceMock.Check got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmCheck.CheckMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCheck.CheckMock.defaultExpectation.results
		if mm_results == nil {
			mmCheck.t.Fatal("No results are set for the AuthServiceMock.Check")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmCheck.funcCheck != nil {
		return mmCheck.funcCheck(ctx, token, method, endpointAddress)
	}
	mmCheck.t.Fatalf("Unexpected call to AuthServiceMock.Check. %v %v %v %v", ctx, token, method, endpointAddress)
	return
}

// CheckAfterCounter returns a count of finished AuthServiceMock.Check invocations
func (mmCheck *AuthServiceMock) CheckAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.afterCheckCounter)
}

// CheckBeforeCounter returns a count of AuthServiceMock.Check invocations
func (mmCheck *AuthServiceMock) CheckBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCheck.beforeCheckCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Check.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCheck *mAuthServiceMockCheck) Calls() []*AuthServiceMockCheckParams {
	mmCheck.mutex.RLock()

	argCopy := make([]*AuthServiceMockCheckParams, len(mmCheck.callArgs))
	copy(argCopy, mmCheck.callArgs)

	mmCheck.mutex.RUnlock()

	return argCopy
}

// MinimockCheckDone returns true if the count of the Check invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockCheckDone() bool {
	if m.CheckMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.CheckMock.invocationsDone()
}

// MinimockCheckInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockCheckInspect() {
	for _, e := range m.CheckMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Check at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterCheckCounter := mm_atomic.LoadUint64(&m.afterCheckCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.CheckMock.defaultExpectation != nil && afterCheckCounter < 1 {
		if m.CheckMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Check at\n%s", m.CheckMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Check at\n%s with params: %#v", m.CheckMock.defaultExpectation.expectationOrigins.origin, *m.CheckMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCheck != nil && afterCheckCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Check at\n%s", m.funcCheckOrigin)
	}

	if !m.CheckMock.invocationsDone() && afterCheckCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Check at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.CheckMock.expectedInvocations), m.CheckMock.expectedInvocationsOrigin, afterCheckCounter)
	}
}

type mAuthServiceMockDummyLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockDummyLoginExpectation
	expectations       []*AuthServiceMockDummyLoginExpectation

	callArgs []*AuthServiceMockDummyLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockDummyLoginExpectation specifies expectation struct of the AuthService.DummyLogin
type AuthServiceMockDummyLoginExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockDummyLoginParams
	paramPtrs          *AuthServiceMockDummyLoginParamPtrs
	expectationOrigins AuthServiceMockDummyLoginExpectationOrigins
	results            *AuthServiceMockDummyLoginResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockDummyLoginParams contains parameters of the AuthService.DummyLogin
type AuthServiceMockDummyLoginParams struct {
	ctx  context.Context
	role model.Role
}

// AuthServiceMockDummyLoginParamPtrs contains pointers to parameters of the AuthService.DummyLogin
type AuthServiceMockDummyLoginParamPtrs struct {
	ctx  *context.Context
	role *model.Role
}

// AuthServiceMockDummyLoginResults contains results of the AuthService.DummyLogin
type AuthServiceMockDummyLoginResults struct {
	s1  string
	err error
}

// AuthServiceMockDummyLoginOrigins contains origins of expectations of the AuthService.DummyLogin
type AuthServiceMockDummyLoginExpectationOrigins struct {
	origin     string
	originCtx  string
	originRole string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDummyLogin *mAuthServiceMockDummyLogin) Optional() *mAuthServiceMockDummyLogin {
	mmDummyLogin.optional = true
	return mmDummyLogin
}

// Expect sets up expected params for AuthService.DummyLogin
func (mmDummyLogin *mAuthServiceMockDummyLogin) Expect(ctx context.Context, role model.Role) *mAuthServiceMockDummyLogin {
	if mmDummyLogin.mock.funcDummyLogin != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Set")
	}

	if mmDummyLogin.defaultExpectation == nil {
		mmDummyLogin.defaultExpectation = &AuthServiceMockDummyLoginExpectation{}
	}

	if mmDummyLogin.defaultExpectation.paramPtrs != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by ExpectParams functions")
	}

	mmDummyLogin.defaultExpectation.params = &AuthServiceMockDummyLoginParams{ctx, role}
	mmDummyLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDummyLogin.expectations {
		if minimock.Equal(e.params, mmDummyLogin.defaultExpectation.params) {
			mmDummyLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDummyLogin.defaultExpectation.params)
		}
	}

	return mmDummyLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.DummyLogin
func (mmDummyLogin *mAuthServiceMockDummyLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockDummyLogin {
	if mmDummyLogin.mock.funcDummyLogin != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Set")
	}

	if mmDummyLogin.defaultExpectation == nil {
		mmDummyLogin.defaultExpectation = &AuthServiceMockDummyLoginExpectation{}
	}

	if mmDummyLogin.defaultExpectation.params != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Expect")
	}

	if mmDummyLogin.defaultExpectation.paramPtrs == nil {
		mmDummyLogin.defaultExpectation.paramPtrs = &AuthServiceMockDummyLoginParamPtrs{}
	}
	mmDummyLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmDummyLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDummyLogin
}

// ExpectRoleParam2 sets up expected param role for AuthService.DummyLogin
func (mmDummyLogin *mAuthServiceMockDummyLogin) ExpectRoleParam2(role model.Role) *mAuthServiceMockDummyLogin {
	if mmDummyLogin.mock.funcDummyLogin != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Set")
	}

	if mmDummyLogin.defaultExpectation == nil {
		mmDummyLogin.defaultExpectation = &AuthServiceMockDummyLoginExpectation{}
	}

	if mmDummyLogin.defaultExpectation.params != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Expect")
	}

	if mmDummyLogin.defaultExpectation.paramPtrs == nil {
		mmDummyLogin.defaultExpectation.paramPtrs = &AuthServiceMockDummyLoginParamPtrs{}
	}
	mmDummyLogin.defaultExpectation.paramPtrs.role = &role
	mmDummyLogin.defaultExpectation.expectationOrigins.originRole = minimock.CallerInfo(1)

	return mmDummyLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.DummyLogin
func (mmDummyLogin *mAuthServiceMockDummyLogin) Inspect(f func(ctx context.Context, role model.Role)) *mAuthServiceMockDummyLogin {
	if mmDummyLogin.mock.inspectFuncDummyLogin != nil {
		mmDummyLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.DummyLogin")
	}

	mmDummyLogin.mock.inspectFuncDummyLogin = f

	return mmDummyLogin
}

// Return sets up results that will be returned by AuthService.DummyLogin
func (mmDummyLogin *mAuthServiceMockDummyLogin) Return(s1 string, err error) *AuthServiceMock {
	if mmDummyLogin.mock.funcDummyLogin != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Set")
	}

	if mmDummyLogin.defaultExpectation == nil {
		mmDummyLogin.defaultExpectation = &AuthServiceMockDummyLoginExpectation{mock: mmDummyLogin.mock}
	}
	mmDummyLogin.defaultExpectation.results = &AuthServiceMockDummyLoginResults{s1, err}
	mmDummyLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDummyLogin.mock
}

// Set uses given function f to mock the AuthService.DummyLogin method
func (mmDummyLogin *mAuthServiceMockDummyLogin) Set(f func(ctx context.Context, role model.Role) (s1 string, err error)) *AuthServiceMock {
	if mmDummyLogin.defaultExpectation != nil {
		mmDummyLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.DummyLogin method")
	}

	if len(mmDummyLogin.expectations) > 0 {
		mmDummyLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.DummyLogin method")
	}

	mmDummyLogin.mock.funcDummyLogin = f
	mmDummyLogin.mock.funcDummyLoginOrigin = minimock.CallerInfo(1)
	return mmDummyLogin.mock
}

// When sets expectation for the AuthService.DummyLogin which will trigger the result defined by the following
// Then helper
func (mmDummyLogin *mAuthServiceMockDummyLogin) When(ctx context.Context, role model.Role) *AuthServiceMockDummyLoginExpectation {
	if mmDummyLogin.mock.funcDummyLogin != nil {
		mmDummyLogin.mock.t.Fatalf("AuthServiceMock.DummyLogin mock is already set by Set")
	}

	expectation := &AuthServiceMockDummyLoginExpectation{
		mock:               mmDummyLogin.mock,
		params:             &AuthServiceMockDummyLoginParams{ctx, role},
		expectationOrigins: AuthServiceMockDummyLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDummyLogin.expectations = append(mmDummyLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.DummyLogin return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockDummyLoginExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockDummyLoginResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.DummyLogin should be invoked
func (mmDummyLogin *mAuthServiceMockDummyLogin) Times(n uint64) *mAuthServiceMockDummyLogin {
	if n == 0 {
		mmDummyLogin.mock.t.Fatalf("Times of AuthServiceMock.DummyLogin mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDummyLogin.expectedInvocations, n)
	mmDummyLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDummyLogin
}

func (mmDummyLogin *mAuthServiceMockDummyLogin) invocationsDone() bool {
	if len(mmDummyLogin.expectations) == 0 && mmDummyLogin.defaultExpectation == nil && mmDummyLogin.mock.funcDummyLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDummyLogin.mock.afterDummyLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDummyLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// DummyLogin implements mm_service.AuthService
func (mmDummyLogin *AuthServiceMock) DummyLogin(ctx context.Context, role model.Role) (s1 string, err error) {
	mm_atomic.AddUint64(&mmDummyLogin.beforeDummyLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmDummyLogin.afterDummyLoginCounter, 1)

	mmDummyLogin.t.Helper()

	if mmDummyLogin.inspectFuncDummyLogin != nil {
		mmDummyLogin.inspectFuncDummyLogin(ctx, role)
	}

	mm_params := AuthServiceMockDummyLoginParams{ctx, role}

	// Record call args
	mmDummyLogin.DummyLoginMock.mutex.Lock()
	mmDummyLogin.DummyLoginMock.callArgs = append(mmDummyLogin.DummyLoginMock.callArgs, &mm_params)
	mmDummyLogin.DummyLoginMock.mutex.Unlock()

	for _, e := range mmDummyLogin.DummyLoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmDummyLogin.DummyLoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDummyLogin.DummyLoginMock.defaultExpectation.Counter, 1)
		mm_want := mmDummyLogin.DummyLoginMock.defaultExpectation.params
		mm_want_ptrs := mmDummyLogin.DummyLoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockDummyLoginParams{ctx, role}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDummyLogin.t.Errorf("AuthServiceMock.DummyLogin got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDummyLogin.DummyLoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.role != nil && !minimock.Equal(*mm_want_ptrs.role, mm_got.role) {
				mmDummyLogin.t.Errorf("AuthServiceMock.DummyLogin got unexpected parameter role, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDummyLogin.DummyLoginMock.defaultExpectation.expectationOrigins.originRole, *mm_want_ptrs.role, mm_got.role, minimock.Diff(*mm_want_ptrs.role, mm_got.role))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDummyLogin.t.Errorf("AuthServiceMock.DummyLogin got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDummyLogin.DummyLoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDummyLogin.DummyLoginMock.defaultExpectation.results
		if mm_results == nil {
			mmDummyLogin.t.Fatal("No results are set for the AuthServiceMock.DummyLogin")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmDummyLogin.funcDummyLogin != nil {
		return mmDummyLogin.funcDummyLogin(ctx, role)
	}
	mmDummyLogin.t.Fatalf("Unexpected call to AuthServiceMock.DummyLogin. %v %v", ctx, role)
	return
}

// DummyLoginAfterCounter returns a count of finished AuthServiceMock.DummyLogin invocations
func (mmDummyLogin *AuthServiceMock) DummyLoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDummyLogin.afterDummyLoginCounter)
}

// DummyLoginBeforeCounter returns a count of AuthServiceMock.DummyLogin invocations
func (mmDummyLogin *AuthServiceMock) DummyLoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDummyLogin.beforeDummyLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.DummyLogin.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDummyLogin *mAuthServiceMockDummyLogin) Calls() []*AuthServiceMockDummyLoginParams {
	mmDummyLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockDummyLoginParams, len(mmDummyLogin.callArgs))
	copy(argCopy, mmDummyLogin.callArgs)

	mmDummyLogin.mutex.RUnlock()

	return argCopy
}

// MinimockDummyLoginDone returns true if the count of the DummyLogin invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockDummyLoginDone() bool {
	if m.DummyLoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DummyLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DummyLoginMock.invocationsDone()
}

// MinimockDummyLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockDummyLoginInspect() {
	for _, e := range m.DummyLoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.DummyLogin at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDummyLoginCounter := mm_atomic.LoadUint64(&m.afterDummyLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DummyLoginMock.defaultExpectation != nil && afterDummyLoginCounter < 1 {
		if m.DummyLoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.DummyLogin at\n%s", m.DummyLoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.DummyLogin at\n%s with params: %#v", m.DummyLoginMock.defaultExpectation.expectationOrigins.origin, *m.DummyLoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDummyLogin != nil && afterDummyLoginCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.DummyLogin at\n%s", m.funcDummyLoginOrigin)
	}

	if !m.DummyLoginMock.invocationsDone() && afterDummyLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.DummyLogin at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DummyLoginMock.expectedInvocations), m.DummyLoginMock.expectedInvocationsOrigin, afterDummyLoginCounter)
	}
}

type mAuthServiceMockLogin struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockLoginExpectation
	expectations       []*AuthServiceMockLoginExpectation

	callArgs []*AuthServiceMockLoginParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockLoginExpectation specifies expectation struct of the AuthService.Login
type AuthServiceMockLoginExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockLoginParams
	paramPtrs          *AuthServiceMockLoginParamPtrs
	expectationOrigins AuthServiceMockLoginExpectationOrigins
	results            *AuthServiceMockLoginResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockLoginParams contains parameters of the AuthService.Login
type AuthServiceMockLoginParams struct {
	ctx       context.Context
	loginInfo *model.UserLoginInfo
}

// AuthServiceMockLoginParamPtrs contains pointers to parameters of the AuthService.Login
type AuthServiceMockLoginParamPtrs struct {
	ctx       *context.Context
	loginInfo **model.UserLoginInfo
}

// AuthServiceMockLoginResults contains results of the AuthService.Login
type AuthServiceMockLoginResults struct {
	s1  string
	err error
}

// AuthServiceMockLoginOrigins contains origins of expectations of the AuthService.Login
type AuthServiceMockLoginExpectationOrigins struct {
	origin          string
	originCtx       string
	originLoginInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mAuthServiceMockLogin) Optional() *mAuthServiceMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Expect(ctx context.Context, loginInfo *model.UserLoginInfo) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.paramPtrs != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by ExpectParams functions")
	}

	mmLogin.defaultExpectation.params = &AuthServiceMockLoginParams{ctx, loginInfo}
	mmLogin.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmLogin.expectations {
		if minimock.Equal(e.params, mmLogin.defaultExpectation.params) {
			mmLogin.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmLogin.defaultExpectation.params)
		}
	}

	return mmLogin
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.ctx = &ctx
	mmLogin.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmLogin
}

// ExpectLoginInfoParam2 sets up expected param loginInfo for AuthService.Login
func (mmLogin *mAuthServiceMockLogin) ExpectLoginInfoParam2(loginInfo *model.UserLoginInfo) *mAuthServiceMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{}
	}

	if mmLogin.defaultExpectation.params != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Expect")
	}

	if mmLogin.defaultExpectation.paramPtrs == nil {
		mmLogin.defaultExpectation.paramPtrs = &AuthServiceMockLoginParamPtrs{}
	}
	mmLogin.defaultExpectation.paramPtrs.loginInfo = &loginInfo
	mmLogin.defaultExpectation.expectationOrigins.originLoginInfo = minimock.CallerInfo(1)

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Inspect(f func(ctx context.Context, loginInfo *model.UserLoginInfo)) *mAuthServiceMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by AuthService.Login
func (mmLogin *mAuthServiceMockLogin) Return(s1 string, err error) *AuthServiceMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &AuthServiceMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &AuthServiceMockLoginResults{s1, err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the AuthService.Login method
func (mmLogin *mAuthServiceMockLogin) Set(f func(ctx context.Context, loginInfo *model.UserLoginInfo) (s1 string, err error)) *AuthServiceMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the AuthService.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the AuthService.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// When sets expectation for the AuthService.Login which will trigger the result defined by the following
// Then helper
func (mmLogin *mAuthServiceMockLogin) When(ctx context.Context, loginInfo *model.UserLoginInfo) *AuthServiceMockLoginExpectation {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("AuthServiceMock.Login mock is already set by Set")
	}

	expectation := &AuthServiceMockLoginExpectation{
		mock:               mmLogin.mock,
		params:             &AuthServiceMockLoginParams{ctx, loginInfo},
		expectationOrigins: AuthServiceMockLoginExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmLogin.expectations = append(mmLogin.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Login return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockLoginExpectation) Then(s1 string, err error) *AuthServiceMock {
	e.results = &AuthServiceMockLoginResults{s1, err}
	return e.mock
}

// Times sets number of times AuthService.Login should be invoked
func (mmLogin *mAuthServiceMockLogin) Times(n uint64) *mAuthServiceMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of AuthServiceMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mAuthServiceMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements mm_service.AuthService
func (mmLogin *AuthServiceMock) Login(ctx context.Context, loginInfo *model.UserLoginInfo) (s1 string, err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin(ctx, loginInfo)
	}

	mm_params := AuthServiceMockLoginParams{ctx, loginInfo}

	// Record call args
	mmLogin.LoginMock.mutex.Lock()
	mmLogin.LoginMock.callArgs = append(mmLogin.LoginMock.callArgs, &mm_params)
	mmLogin.LoginMock.mutex.Unlock()

	for _, e := range mmLogin.LoginMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)
		mm_want := mmLogin.LoginMock.defaultExpectation.params
		mm_want_ptrs := mmLogin.LoginMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockLoginParams{ctx, loginInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.loginInfo != nil && !minimock.Equal(*mm_want_ptrs.loginInfo, mm_got.loginInfo) {
				mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameter loginInfo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmLogin.LoginMock.defaultExpectation.expectationOrigins.originLoginInfo, *mm_want_ptrs.loginInfo, mm_got.loginInfo, minimock.Diff(*mm_want_ptrs.loginInfo, mm_got.loginInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmLogin.t.Errorf("AuthServiceMock.Login got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmLogin.LoginMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the AuthServiceMock.Login")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin(ctx, loginInfo)
	}
	mmLogin.t.Fatalf("Unexpected call to AuthServiceMock.Login. %v %v", ctx, loginInfo)
	return
}

// LoginAfterCounter returns a count of finished AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of AuthServiceMock.Login invocations
func (mmLogin *AuthServiceMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Login.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmLogin *mAuthServiceMockLogin) Calls() []*AuthServiceMockLoginParams {
	mmLogin.mutex.RLock()

	argCopy := make([]*AuthServiceMockLoginParams, len(mmLogin.callArgs))
	copy(argCopy, mmLogin.callArgs)

	mmLogin.mutex.RUnlock()

	return argCopy
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		if m.LoginMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s with params: %#v", m.LoginMock.defaultExpectation.expectationOrigins.origin, *m.LoginMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

type mAuthServiceMockRegister struct {
	optional           bool
	mock               *AuthServiceMock
	defaultExpectation *AuthServiceMockRegisterExpectation
	expectations       []*AuthServiceMockRegisterExpectation

	callArgs []*AuthServiceMockRegisterParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// AuthServiceMockRegisterExpectation specifies expectation struct of the AuthService.Register
type AuthServiceMockRegisterExpectation struct {
	mock               *AuthServiceMock
	params             *AuthServiceMockRegisterParams
	paramPtrs          *AuthServiceMockRegisterParamPtrs
	expectationOrigins AuthServiceMockRegisterExpectationOrigins
	results            *AuthServiceMockRegisterResults
	returnOrigin       string
	Counter            uint64
}

// AuthServiceMockRegisterParams contains parameters of the AuthService.Register
type AuthServiceMockRegisterParams struct {
	ctx          context.Context
	registerInfo *model.UserRegistration
}

// AuthServiceMockRegisterParamPtrs contains pointers to parameters of the AuthService.Register
type AuthServiceMockRegisterParamPtrs struct {
	ctx          *context.Context
	registerInfo **model.UserRegistration
}

// AuthServiceMockRegisterResults contains results of the AuthService.Register
type AuthServiceMockRegisterResults struct {
	up1 *model.User
	err error
}

// AuthServiceMockRegisterOrigins contains origins of expectations of the AuthService.Register
type AuthServiceMockRegisterExpectationOrigins struct {
	origin             string
	originCtx          string
	originRegisterInfo string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRegister *mAuthServiceMockRegister) Optional() *mAuthServiceMockRegister {
	mmRegister.optional = true
	return mmRegister
}

// Expect sets up expected params for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) Expect(ctx context.Context, registerInfo *model.UserRegistration) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.paramPtrs != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by ExpectParams functions")
	}

	mmRegister.defaultExpectation.params = &AuthServiceMockRegisterParams{ctx, registerInfo}
	mmRegister.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRegister.expectations {
		if minimock.Equal(e.params, mmRegister.defaultExpectation.params) {
			mmRegister.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRegister.defaultExpectation.params)
		}
	}

	return mmRegister
}

// ExpectCtxParam1 sets up expected param ctx for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) ExpectCtxParam1(ctx context.Context) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &AuthServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.ctx = &ctx
	mmRegister.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRegister
}

// ExpectRegisterInfoParam2 sets up expected param registerInfo for AuthService.Register
func (mmRegister *mAuthServiceMockRegister) ExpectRegisterInfoParam2(registerInfo *model.UserRegistration) *mAuthServiceMockRegister {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{}
	}

	if mmRegister.defaultExpectation.params != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Expect")
	}

	if mmRegister.defaultExpectation.paramPtrs == nil {
		mmRegister.defaultExpectation.paramPtrs = &AuthServiceMockRegisterParamPtrs{}
	}
	mmRegister.defaultExpectation.paramPtrs.registerInfo = &registerInfo
	mmRegister.defaultExpectation.expectationOrigins.originRegisterInfo = minimock.CallerInfo(1)

	return mmRegister
}

// Inspect accepts an inspector function that has same arguments as the AuthService.Register
func (mmRegister *mAuthServiceMockRegister) Inspect(f func(ctx context.Context, registerInfo *model.UserRegistration)) *mAuthServiceMockRegister {
	if mmRegister.mock.inspectFuncRegister != nil {
		mmRegister.mock.t.Fatalf("Inspect function is already set for AuthServiceMock.Register")
	}

	mmRegister.mock.inspectFuncRegister = f

	return mmRegister
}

// Return sets up results that will be returned by AuthService.Register
func (mmRegister *mAuthServiceMockRegister) Return(up1 *model.User, err error) *AuthServiceMock {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	if mmRegister.defaultExpectation == nil {
		mmRegister.defaultExpectation = &AuthServiceMockRegisterExpectation{mock: mmRegister.mock}
	}
	mmRegister.defaultExpectation.results = &AuthServiceMockRegisterResults{up1, err}
	mmRegister.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// Set uses given function f to mock the AuthService.Register method
func (mmRegister *mAuthServiceMockRegister) Set(f func(ctx context.Context, registerInfo *model.UserRegistration) (up1 *model.User, err error)) *AuthServiceMock {
	if mmRegister.defaultExpectation != nil {
		mmRegister.mock.t.Fatalf("Default expectation is already set for the AuthService.Register method")
	}

	if len(mmRegister.expectations) > 0 {
		mmRegister.mock.t.Fatalf("Some expectations are already set for the AuthService.Register method")
	}

	mmRegister.mock.funcRegister = f
	mmRegister.mock.funcRegisterOrigin = minimock.CallerInfo(1)
	return mmRegister.mock
}

// When sets expectation for the AuthService.Register which will trigger the result defined by the following
// Then helper
func (mmRegister *mAuthServiceMockRegister) When(ctx context.Context, registerInfo *model.UserRegistration) *AuthServiceMockRegisterExpectation {
	if mmRegister.mock.funcRegister != nil {
		mmRegister.mock.t.Fatalf("AuthServiceMock.Register mock is already set by Set")
	}

	expectation := &AuthServiceMockRegisterExpectation{
		mock:               mmRegister.mock,
		params:             &AuthServiceMockRegisterParams{ctx, registerInfo},
		expectationOrigins: AuthServiceMockRegisterExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRegister.expectations = append(mmRegister.expectations, expectation)
	return expectation
}

// Then sets up AuthService.Register return parameters for the expectation previously defined by the When method
func (e *AuthServiceMockRegisterExpectation) Then(up1 *model.User, err error) *AuthServiceMock {
	e.results = &AuthServiceMockRegisterResults{up1, err}
	return e.mock
}

// Times sets number of times AuthService.Register should be invoked
func (mmRegister *mAuthServiceMockRegister) Times(n uint64) *mAuthServiceMockRegister {
	if n == 0 {
		mmRegister.mock.t.Fatalf("Times of AuthServiceMock.Register mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRegister.expectedInvocations, n)
	mmRegister.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRegister
}

func (mmRegister *mAuthServiceMockRegister) invocationsDone() bool {
	if len(mmRegister.expectations) == 0 && mmRegister.defaultExpectation == nil && mmRegister.mock.funcRegister == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRegister.mock.afterRegisterCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRegister.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Register implements mm_service.AuthService
func (mmRegister *AuthServiceMock) Register(ctx context.Context, registerInfo *model.UserRegistration) (up1 *model.User, err error) {
	mm_atomic.AddUint64(&mmRegister.beforeRegisterCounter, 1)
	defer mm_atomic.AddUint64(&mmRegister.afterRegisterCounter, 1)

	mmRegister.t.Helper()

	if mmRegister.inspectFuncRegister != nil {
		mmRegister.inspectFuncRegister(ctx, registerInfo)
	}

	mm_params := AuthServiceMockRegisterParams{ctx, registerInfo}

	// Record call args
	mmRegister.RegisterMock.mutex.Lock()
	mmRegister.RegisterMock.callArgs = append(mmRegister.RegisterMock.callArgs, &mm_params)
	mmRegister.RegisterMock.mutex.Unlock()

	for _, e := range mmRegister.RegisterMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.up1, e.results.err
		}
	}

	if mmRegister.RegisterMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRegister.RegisterMock.defaultExpectation.Counter, 1)
		mm_want := mmRegister.RegisterMock.defaultExpectation.params
		mm_want_ptrs := mmRegister.RegisterMock.defaultExpectation.paramPtrs

		mm_got := AuthServiceMockRegisterParams{ctx, registerInfo}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.registerInfo != nil && !minimock.Equal(*mm_want_ptrs.registerInfo, mm_got.registerInfo) {
				mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameter registerInfo, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRegister.RegisterMock.defaultExpectation.expectationOrigins.originRegisterInfo, *mm_want_ptrs.registerInfo, mm_got.registerInfo, minimock.Diff(*mm_want_ptrs.registerInfo, mm_got.registerInfo))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRegister.t.Errorf("AuthServiceMock.Register got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRegister.RegisterMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRegister.RegisterMock.defaultExpectation.results
		if mm_results == nil {
			mmRegister.t.Fatal("No results are set for the AuthServiceMock.Register")
		}
		return (*mm_results).up1, (*mm_results).err
	}
	if mmRegister.funcRegister != nil {
		return mmRegister.funcRegister(ctx, registerInfo)
	}
	mmRegister.t.Fatalf("Unexpected call to AuthServiceMock.Register. %v %v", ctx, registerInfo)
	return
}

// RegisterAfterCounter returns a count of finished AuthServiceMock.Register invocations
func (mmRegister *AuthServiceMock) RegisterAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.afterRegisterCounter)
}

// RegisterBeforeCounter returns a count of AuthServiceMock.Register invocations
func (mmRegister *AuthServiceMock) RegisterBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRegister.beforeRegisterCounter)
}

// Calls returns a list of arguments used in each call to AuthServiceMock.Register.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRegister *mAuthServiceMockRegister) Calls() []*AuthServiceMockRegisterParams {
	mmRegister.mutex.RLock()

	argCopy := make([]*AuthServiceMockRegisterParams, len(mmRegister.callArgs))
	copy(argCopy, mmRegister.callArgs)

	mmRegister.mutex.RUnlock()

	return argCopy
}

// MinimockRegisterDone returns true if the count of the Register invocations corresponds
// the number of defined expectations
func (m *AuthServiceMock) MinimockRegisterDone() bool {
	if m.RegisterMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RegisterMock.invocationsDone()
}

// MinimockRegisterInspect logs each unmet expectation
func (m *AuthServiceMock) MinimockRegisterInspect() {
	for _, e := range m.RegisterMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRegisterCounter := mm_atomic.LoadUint64(&m.afterRegisterCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RegisterMock.defaultExpectation != nil && afterRegisterCounter < 1 {
		if m.RegisterMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s", m.RegisterMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s with params: %#v", m.RegisterMock.defaultExpectation.expectationOrigins.origin, *m.RegisterMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRegister != nil && afterRegisterCounter < 1 {
		m.t.Errorf("Expected call to AuthServiceMock.Register at\n%s", m.funcRegisterOrigin)
	}

	if !m.RegisterMock.invocationsDone() && afterRegisterCounter > 0 {
		m.t.Errorf("Expected %d calls to AuthServiceMock.Register at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RegisterMock.expectedInvocations), m.RegisterMock.expectedInvocationsOrigin, afterRegisterCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *AuthServiceMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockCheckInspect()

			m.MinimockDummyLoginInspect()

			m.MinimockLoginInspect()

			m.MinimockRegisterInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *AuthServiceMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *AuthServiceMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockCheckDone() &&
		m.MinimockDummyLoginDone() &&
		m.MinimockLoginDone() &&
		m.MinimockRegisterDone()
}
